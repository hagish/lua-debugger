<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <meta name="description" content="Collection of sample code snippets for wxWidgets">
  <meta name="keywords" content="sample, code, snippets, wxWidgets">
  <meta name="robots" content="noindex, follow">
  <meta name="made" content="mailto:wyo@users.sourceforge.net">
  <meta name="language" content="en">
  <meta name="generator" content="wxCode">
  <style type="text/css"> /* <![CDATA[ */ @import url(default.css); /* ]]> */ </style>
  <title>wxCode: wxScintilla API reference</title>
  <link rel="start"    title=" Start " accesskey="S" href="index.html" target=_top>
</head>
<body>
[<a href="index.php" target=_top accesskey="H">Home</a>]

<h3>wxScintilla API reference</h3>

<p>
Derived from the Scintilla documentation (edited 3/June/2005 NH)
</p>

<h3>Introduction</h3>

<p>The Windows version of Scintilla is a Windows Control. As such, its primary programming interface is through Windows messages. Early versions of Scintilla emulated much of the API defined by the standard Windows Edit and RichEdit controls but those APIs are now deprecated in favour of Scintilla's own, more consistent API. In addition to messages performing the actions of a normal Edit control, Scintilla allows control of syntax styling, folding, markers, autocompletion and call tips.
</p>
<p>
The GTK+ version also uses messages in a similar way to the Windows version. This is different to normal GTK+ practice but made it easier to implement rapidly.
</p>
<p>In the descriptions that follow, the commands are described as function calls with zero, one or two arguments. These two arguments are the standard <code>wParam</code> and <code>lParam</code> familiar to Windows programmers. Although the commands only use the arguments described, because all messages have two arguments whether Scintilla uses them or not, it is strongly recommended that any unused arguments are set to 0. This allows future enhancement of messages without the risk of breaking existing code. Common argument types are:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Common argument types"><tbody valign="top">
<tr>
  <th align="left">bool</th>
  <td>Arguments expect the values 0 for <code>false</code> and 1 for <code>true</code>.</td>
</tr>
<tr>
  <th align="left">int</th>
  <td>Arguments are 32-bit signed integers.</td>
</tr>
<tr>
  <th align="left">const char *</th>
  <td>Arguments point at text that is being passed to Scintilla but not modified. The text   may be zero terminated or another argument may specify the character count, the   description will make this clear.</td>
</tr>
<tr>
  <th align="left">char *</th>
  <td>Arguments point at text buffers that Scintilla will fill with text. In some cases,   another argument will tell Scintilla the buffer size. In others, you must make sure that   the buffer is big enough to hold the requested text. If a NULL pointer (0) is passed   then, for SCI_* calls, the length that should be allocated is returned.</td>
</tr>
<tr>
  <th align="left" id="colour">colour</th>
  <td>Colours are set using the RGB format (Red, Green, Blue). The intensity of each colour   is set in the range 0 to 255. If you have three such intensities, they are combined as:   red | (green &lt;&lt; 8) | (blue &lt;&lt; 16). If you set all intensities to 255, the   colour is white. If you set all intensities to 0, the colour is black. When you set a   colour, you are making a request. What you will get depends on the capabilities of the   system and the current screen mode.</td>
</tr>
</tbody></table>

<div class="divider1"></div>
<h3 id="MessageCategories">Contents</h3>

<table cellpadding="2" cellspacing="2" border="0" summary="Message categories"><tbody>
<tr>
  <td>o <a class="toc" href="#TextRetrievalAndModification">Text retrieval and modification</a></td>
  <td>o <a class="toc" href="#Searching">Searching and replacing</a></td>
  <td>o <a class="toc" href="#Overtype">Overtype</a></td>
</tr><tr>
  <td>o <a class="toc" href="#CutCopyAndPaste">Cut, copy and paste</a></td>
  <td>o <a class="toc" href="#ErrorHandling">Error handling</a></td>
  <td>o <a class="toc" href="#UndoAndRedo">Undo and Redo</a></td>
</tr><tr>
  <td>o <a class="toc" href="#SelectionAndInformation">Selection and information</a></td>
  <td>o <a class="toc" href="#ScrollingAndAutomaticScrolling">Scrolling and automatic scrolling</a></td>
  <td>o <a class="toc" href="#WhiteSpace">White space</a></td>
</tr><tr>
  <td>o <a class="toc" href="#Cursor">Cursor</a></td>
  <td>o <a class="toc" href="#MouseCapture">Mouse capture</a></td>
  <td>o <a class="toc" href="#LineEndings">Line endings</a></td>
</tr><tr>
  <td>o <a class="toc" href="#Styling">Styling</a></td>
  <td>o <a class="toc" href="#StyleDefinition">Style definition</a></td>
  <td>o <a class="toc" href="#CaretAndSelectionStyles">Caret, selection, and hotspot styles</a></td>
</tr><tr>
  <td>o <a class="toc" href="#Margins">Margins</a></td>
  <td>o <a class="toc" href="#OtherSettings">Other settings</a></td>
  <td>o <a class="toc" href="#BraceHighlighting">Brace highlighting</a></td>
</tr><tr>
  <td>o <a class="toc" href="#TabsAndIndentationGuides">Tabs and Indentation Guides</a></td>
  <td>o <a class="toc" href="#Markers">Markers</a></td>
  <td>o <a class="toc" href="#Indicators">Indicators</a></td>
</tr><tr>
  <td>o <a class="toc" href="#Autocompletion">Autocompletion</a></td>
  <td>o <a class="toc" href="#UserLists">User lists</a></td>
  <td>o <a class="toc" href="#CallTips">Call tips</a></td>
</tr><tr>
  <td>o <a class="toc" href="#KeyboardCommands">Keyboard commands</a></td>
  <td>o <a class="toc" href="#KeyBindings">Key bindings</a></td>
  <td>o <a class="toc" href="#PopupEditMenu">Popup edit menu</a></td>
</tr><tr>
  <td>o <a class="toc" href="#MacroRecording">Macro recording</a></td>
  <td>o <a class="toc" href="#Printing">Printing</a></td>
  <td>o <a class="toc" href="#LineWrapping">Line wrapping</a></td>
</tr><tr>
  <td>o <a class="toc" href="#MultipleViews">Multiple views</a></td>
  <td>o <a class="toc" href="#Folding">Folding</a></td>
  <td>o <a class="toc" href="#Lexer">Lexer</a></td>
</tr><tr>
  <td>o <a class="toc" href="#Zooming">Zooming</a></td>
  <td>o <a class="toc" href="#LongLines">Long lines</a></td>
  <td>o <a class="toc" href="#Notifications">Notifications</a></td>
</tr>
</tbody></table>

<p>
Functions with names of the form <code>Set...</code> often have a companion <code>Get...</code>. To save tedious repetition, if the <code>Get...</code> returns the value set by the <code>Set...</code>, the routines are described together.</p>

<div class="divider1"></div>
<h3 id="TextRetrievalAndModification">Text retrieval and modification</h3>

<p>
Each character in a Scintilla document is followed by an associated byte of styling information. The combination of a character byte and a style byte is called a cell. Style bytes are interpreted as a style index in the low 5 bits and as 3 individual bits of <a class="jump" href="#Indicators">indicators</a>. This allows 32 fundamental styles, which is enough for most languages, and three in dependent indicators. For example, syntax errors, deprecated names and bad indentation could all be displayed at once. The number of bits used for styles can be altered with <a class="message" href="#SetStyleBits"><code>SetStyleBits</code></a> up to a maximum of 7 bits (some languages require more bits, e.g. HTML=7 bits). The remaining bits can be used for indicators.
</p>
<p>
Positions within the Scintilla document refer to a character or the gap before that character. The first character in a document is 0, the second 1 and so on. If a document contains <code>nLen</code> characters, the last character is numbered <code>nLen</code>-1. The caret exists between character positions and can be located from before the first character (0) to after the last character (<code>nLen</code>).
</p>
<p>
There are places where the caret can not go where two character bytes make up one character. This occurs when a DBCS character from a language like Japanese is included in the document or when line ends are marked with the CP/M standard of a carriage return followed by a line feed. The <code>wxSCI_INVALID_POSITION</code> constant (-1) represents an invalid position within the document.
</p>
<p>
All lines of text in Scintilla are the same height, and this height is calculated from the largest font in any current style. This restriction is for performance; if lines differed in height then calculations involving positioning of text would require the text to be styled first.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#GetText">wxString GetText()</a></li>
<li><a class="message" href="#SetText">void SetText (const wxString& text)</a></li>
<li><a class="message" href="#GetLine">wxString GetLine (int line)</a></li>
<li><a class="message" href="#ReplaceSelection">void ReplaceSelection (const wxString& text)</a></li>
<li><a class="message" href="#SetReadOnly">void SetReadOnly (bool readOnly)</a></li>
<li><a class="message" href="#GetReadOnly">bool GetReadOnly()</a></li>
<li><a class="message" href="#GetTextRange">wxString GetTextRange (int startPos, int endPos)</a></li>
<li><a class="message" href="#Allocate">void Allocate (int bytes)</a></li>
<li><a class="message" href="#AddText">void AddText (const int length, const wxString& text)</a></li>
<li><a class="message" href="#AddStyledText">void AddStyledText (const wxMemoryBuffer& data)</a></li>
<li><a class="message" href="#AppendText">void AppendText (int length, const wxString& text)</a></li>
<li><a class="message" href="#InsertText">void InsertText (int pos, const wxString& text)</a></li>
<li><a class="message" href="#ClearAll">void ClearAll()</a></li>
<li><a class="message" href="#ClearDocumentStyle">void ClearDocumentStyle()</a></li>
<li><a class="message" href="#GetCharAt">int GetCharAt (int pos)</a></li>
<li><a class="message" href="#GetStyleAt">int GetStyleAt (int pos)</a></li>
<li><a class="message" href="#GetStyledText">wxMemoryBuffer GetStyledText (int startPos, int endPos)</a></li>
<li><a class="message" href="#SetStyleBits">void SetStyleBits (int bits)</a></li>
<li><a class="message" href="#GetStyleBits">int GetStyleBits</a></li>
<li><a class="message" href="#GetStyleBitsNeeded">int GetStyleBitsNeeded ()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="GetText">wxString GetText()</a></h4>
<p>
Returns all the characters of text from the start of the document. If you then save the text, you should use <code>SetSavePoint</code> to mark the text as unmodified.
</p>
<p>
See also: <code><a class="message" href="#GetSelectedText">GetSelectedText</a>, <a class="message" href="#GetCurLine">GetCurLine</a>, <a class="message" href="#GetLine">GetLine</a>, <a class="message" href="#GetStyledText">GetStyledText</a>, <a class="message" href="#GetTextRange">GetTextRange</a></code>
</p>

<div class="divider2"></div>
<h4><a name="SetText">void SetText (const wxString& text)</a></h4>
<p>
Replaces all the text in the document with the text string you pass in. Any previous existing text is deleted.
</p>

<div class="divider2"></div>
<h4><a name="GetLine">wxString GetLine (int line)</a></h4>
<p>
Returns a string with the contents of the nominated line (line numbers start at 0).
</p>
<p>
See also: <code><a class="message" href="#GetCurLine">GetCurLine</a>, <a class="message" href="#GetSelectedText">GetSelectedText</a>, <a class="message" href="#GetTextRange">GetTextRange</a>, <a class="message" href="#GetStyledText">GetStyledText</a>, <a class="message" href="#GetText">GetText</a></code>
</p>

<div class="divider2"></div>
<h4><a name="ReplaceSelection">void ReplaceSelection (const wxString& text)</a></h4>
<p>
The currently selected text between the <a class="jump" href="#SelectionAndInformation">anchor and the current position</a> is replaced by the text string. If the anchor and current position are the same (meaning no selection), the text is inserted at the caret position. The caret is positioned after the inserted text and the caret is scrolled into view.
</p>

<div class="divider2"></div>
<h4><a name="SetReadOnly">void SetReadOnly (bool readOnly)</a><br />
    <a name="GetReadOnly">bool GetReadOnly()</a></h4>
<p>
Set and get the read-only flag of the document. If you mark a document as read only, attempts to modify the text will fail and cause the <a class="message" href="#wxEVT_SCI_MODIFYATTEMPTRO"><code>wxEVT_SCI_MODIFYATTEMPTRO</code></a> notification.
</p>

<div class="divider2"></div>
<h4><a name="GetTextRange">wxString GetTextRange (int startPos, int endPos)</a></h4>
<p>
Returns the text between the positions <code>startPos</code> and <code>endPos</code>. If <code>endPos</code> is wxSCI_INVALID_POSITION, text is returned to the end of the document.
</p>
<p>
See also: <code><a class="message" href="#GetSelectedText">GetSelectedText</a>, <a class="message" href="#GetLine">GetLine</a>, <a class="message" href="#GetCurLine">GetCurLine</a>, <a class="message" href="#GetStyledText">GetStyledText</a>, <a class="message" href="#GetText">GetText</a></code>
</p>

<div class="divider2"></div>
<h4><a name="GetStyledText">wxMemoryBuffer GetStyledText (int startPos, int endPos)</a></h4>
<p>
Returns the styled text into a buffer using two bytes for each cell, with the character at the lower address of each pair and the style byte at the upper address. Characters between the positions <code>startPos</code> and <code>endPos</code> are copied.
</p>
<p>
See also: <code><a class="message" href="#GetSelectedText">GetSelectedText</a>, <a class="message" href="#GetLine">GetLine</a>, <a class="message" href="#GetCurLine">GetCurLine</a>, <a class="message" href="#GetTextRange">GetTextRange</a>, <a class="message" href="#GetText">GetText</a></code>
</p>

<div class="divider2"></div>
<h4><a name="Allocate">void Allocate (int bytes)</a></h4>
<p>
Allocate a document buffer large enough to store a given number of bytes.  The document will not be made smaller than its current contents.
</p>
<p>
<b>Note:</b> Do not use this function if you don't know what you exactly do.
</p>

<div class="divider2"></div>
<h4><a name="AddText">void AddText (const wxString& text)</a><br />
                      void AddText (const int length, const wxString& text)</a></h4>
<p>
Inserts the string at the current position. The current position is set at the end of the inserted text, but it is not scrolled into view. If you need to add strings with binary values (e.g. Unicode characters), use the form with the <code>length</code> parameter.
</p>

<div class="divider2"></div>
<h4><a name="AddStyledText">void AddStyledText (const wxMemoryBuffer& data)</a></h4>
<p>
This behaves just like <code>AddText</code>, but inserts styled text.
</p>

<div class="divider2"></div>
<h4><a name="AppendText">void AppendText (const wxString& text)</a><br />
                         void AppendText (int length, const wxString& text)</a></h4>
<p>
Appends the string at the last position in the document. The current selection is not changed and the new text is not scrolled into view. If you need to add strings with binary values (e.g. Unicode characters), use the form with the <code>length</code> parameter.
</p>

<div class="divider2"></div>
<h4><a name="InsertText">void InsertText (int pos, const wxString& text)</a></h4>
<p>
Inserts the string at position <code>pos</code> or at the current position if <code>pos</code> is wxSCI_INVALID_POSITION. The current position is set at the end of the inserted text, but it is not scrolled into view.
</p>

<div class="divider2"></div>
<h4><a name="ClearAll">void ClearAll()</a></h4>
<p>
Deletes all the text (unless the document is read-only).
</p>

<div class="divider2"></div>
<h4><a name="ClearDocumentStyle">void ClearDocumentStyle()</a></h4>
<p>
When wanting to completely restyle the document, for example after choosing a lexer, the <code>ClearDocumentStyle</code> can be used to clear all styling information and reset the folding state.
</p>
<p>
See also: <code><a class="message" href="#Colourise">Colourise</a></code>
</p>

<div class="divider2"></div>
<h4><a name="GetCharAt">int GetCharAt (int pos)</a></h4>
<p>
Returns the character at <code>pos</code> in the document. If <code>pos</code> is negative or past the end of the document, returns 0.
</p>

<div class="divider2"></div>
<h4><a name="GetStyleAt">int GetStyleAt (int pos)</a></h4>
<p>
Returns the style at <code>pos</code> in the document. If <code>pos</code> is negative or past the end of the document, returns 0.
</p>

<div class="divider2"></div>
<h4><a name="SetStyleBits">void SetStyleBits (int bits)</a><br />
    <a name="GetStyleBits">int GetStyleBits</a></h4>
<p>
Sets and reads back the number of bits in each cell to use for styling, to a maximum of 7 style bits. The remaining bits can be used as indicators. The default setting is <code>5</code> style bits.
</p>

<div class="divider2"></div>
<h4><a name="GetStyleBitsNeeded">int GetStyleBitsNeeded ()</a></h4>
<p>Retrieve the number of bits the current lexer needs for styling. This should normally be the argument to <a class="message" href="#SetStyleBits">SetStyleBits</a>.
</p>

<div class="divider1"></div>
<h3 id="Searching">Searching</h3>

<p>
See also: <a class="jump" href="#SearchAndReplaceUsingTheTarget">Search and replace using the target</a>
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#FindText">int FindText (int minPos, int maxPos, const wxString& text, int flags = 0, int* lengthFound = NULL)</a></li>
<li><a class="message" href="#SearchAnchor">void SearchAnchor()</a></li>
<li><a class="message" href="#SearchNext">int SearchNext (int flags, const wxString& text)</a></li>
<li><a class="message" href="#SearchPrev">int SearchPrev (int flags, const wxString& text)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="searchFlags"><code>searchFlags</code></a></h4>
<p>
Several of the search routines use flag options, which include a simple regular expression search. Combine the flag options by adding them:
</p>
<table border="0" summary="Search flags"><tbody>
<tr>
  <td><code>wxSCI_FIND_MATCHCASE</code></td>
  <td>A match only occurs with text that matches the <code>case</code> of the search string.</td>
</tr><tr>
  <td><code>wxSCI_FIND_WHOLEWORD</code></td>
  <td>A match only occurs if the characters before and after are <code>not word characters</code>.</td>
</tr><tr>
  <td><code>wxSCI_FIND_WORDSTART</code></td>
  <td>A match only occurs if the character before is <code>not a word character</code>.</td>
</tr><tr>
  <td><code>wxSCI_FIND_REGEXP</code></td>
  <td>The search string should be interpreted as a <code>regular expression</code>.</td>
</tr><tr>
  <td><code>wxSCI_FIND_POSIX</code></td>
  <td>Treat regular expression in a more <code>POSIX compatible</code> manner by interpreting bare (and) for tagged sections rather than \( and \).</td>
</tr>
</tbody></table>
<p>
If <code>wxSCI_FIND_REGEXP</code> is not included in the <code>searchFlags</code>, you can search backwards to find the previous occurrence of a search string by setting the end of the search range before the start. If <code>wxSCI_FIND_REGEXP</code> is included, searches are always from a lower position to a higher position, even if the search range is awkward.
</p>
<p>
In a regular expression, special characters interpreted are:
</p>
<table border="0" summary="Regular expression synopsis"><tbody>
<tr>
  <td><code>.</code></td>
  <td>Matches any character</td>
</tr><tr>
  <td><code>\(</code></td>
  <td>This marks the start of a region for tagging a match.</td>
</tr><tr>
  <td><code>\)</code></td>
  <td>This marks the end of a tagged region.</td>
</tr><tr>
  <td><code>\n</code></td>
  <td>Where <code>n</code> is 1 through 9 refers to the first through ninth tagged region   when replacing. For example, if the search string was <code>Fred\([1-9]\)XXX</code> and   the replace string was <code>Sam\1YYY</code>, when applied to <code>Fred2XXX</code> this   would generate <code>Sam2YYY</code>.</td>
</tr><tr>
  <td><code>\&lt;</code></td>
  <td>This matches the start of a word using Scintilla's definitions of words.</td>
</tr><tr>
  <td>\&gt;</td>
  <td>This matches the end of a word using Scintilla's definition of words.</td>
</tr><tr>
  <td><code>\x</code></td>
  <td>This allows you to use a character x that would otherwise have a special meaning. For   example, \[ would be interpreted as [ and not as the start of a character set.</td>
</tr><tr>
  <td><code>[...]</code></td>
  <td>This indicates a set of characters, for example, [abc] means any of the characters a,   b or c. You can also use ranges, for example [a-z] for any lower case character.</td>
</tr><tr>
  <td><code>[^...]</code></td>
  <td>The complement of the characters in the set. For example, [^A-Za-z] means any   character except an alphabetic character.</td>
</tr>
<tr>
  <td><code>^</code></td>
  <td>This matches the start of a line (unless used inside a set, see above).</td>
</tr><tr>
  <td><code>$</code></td>
  <td>This matches the end of a line.</td>
</tr><tr>
  <td><code>*</code></td>
  <td>This matches 0 or more times. For example, <code>Sa*m</code> matches <code>Sm</code>,   <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> and so on.</td>
</tr><tr>
  <td><code>+</code></td>
  <td>This matches 1 or more times. For example, <code>Sa+m</code> matches <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> and so on.</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="FindText">int FindText (int minPos, int maxPos, const wxString& text, int flags = 0, int* lengthFound = NULL)</a></h4>
<p>
FindText performs a straightforward text search through the entire document. The <code>minPos</code> and <code>maxPos</code> arguments specify the range within the Document to search.  No surprise, the <code>text</code> argument is a string object containing the string to search for. The <code>flags</code> argument controls the search. You can set <code>maxPos</code> less than <code>minPos</code> to search in reverse. Returns the start position of the found text, or wxSCI_INVALID_POSITION if it isn't found. If <code>lengthFound</code> is given the length of the found text is returned.
</p>
<p>
See also: <code><a class="message" href="#SearchInTarget">SearchInTarget</a></code>
</p>

<div class="divider2"></div>
<h4><a name="SearchAnchor">void SearchAnchor()</a><br />
    <a name="SearchNext">int SearchNext (int flags, const wxString& text)</a><br />
    <a name="SearchPrev">int SearchPrev (int flags, const wxString& text)</a></h4>
<p>
These provide relocatable search support. This allows multiple incremental interactive searches to be macro recorded while still setting the selection to found text so the find/select operation is self-contained. They send <a class="message" href="#wxEVT_SCI_MACRORECORD"><code>wxEVT_SCI_MACRORECORD</code></a> <a class="jump" href="#Notifications">notifications</a> if macro recording is enabled.
</p>
<p>
<code>SearchAnchor</code> sets the search start point used by <code>SearchNext</code> and <code>SearchPrev</code> to the start of the current selection, that is, the end of the selection that is nearer to the start of the document. You should always call this before calling either of <code>SearchNext</code> or <code>SearchPrev</code>.
</p>
<p>
<code>SearchNext</code> and <code>SearchPrev</code> search for the next and previous occurrence of the search string pointed at by text. The search is modified by the <a class="jump" href="#searchFlags"><code>searchFlags</code></a>. If you request a regular expression, <code>SearchPrev</code> finds the first occurrence of the search string in the document, not the previous one before the anchor point.
</p>
<p>
Return value is the start position of the matching text, otherwise wxSCI_INVALID_POSITION if nothing is found. The selection is updated to show the matched text, but is not scrolled into view.
</p>
<p>
See also: <code><a class="message" href="#SearchInTarget">SearchInTarget</code></a>
</p>

<div class="divider1"></div>
<h3 id="SearchAndReplaceUsingTheTarget">Search and replace using the target</a></h4>

<p>
Searching can be performed within the target range with <code>SearchInTarget</code>, which uses a counted string to allow searching for null characters. It returns the length of range or wxSCI_INVALID_POSITION if not found, in which case the target is not moved. The flags used by <code>SearchInTarget</code> such as <code>wxSCI_FIND_MATCHCASE</code>, <code>wxSCI_FIND_WHOLEWORD</code>, <code>wxSCI_FIND_WORDSTART</code>, and <code>wxSCI_FIND_REGEXP</code> can be set with <code>SetSearchFlags</code>. <code>SearchInTarget</code> may be simpler for some clients to use than <a class="message" href="#FindText"><code>FindText</code></a>.
</p>
<p>
Using <a class="message" href="#ReplaceSelection"><code>ReplaceSelection</code></a>, modifications cause scrolling and other visible changes, which may take some time and cause unwanted display updates. If performing many changes, such as a replace all command, the target can be used instead. First, set the target, i.e. the range to be replaced. Then call <code>ReplaceTarget</code> or <code>ReplaceTargetRE</code>.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#SetTargetStart">void SetTargetStart (int pos)</a></li>
<li><a class="message" href="#GetTargetStart">int GetTargetStart()</a></li>
<li><a class="message" href="#SetTargetEnd">void SetTargetEnd (int pos)</a></li>
<li><a class="message" href="#GetTargetEnd">int GetTargetEnd()</a></li>
<li><a class="message" href="#TargetFromSelection">void TargetFromSelection()</a></li>
<li><a class="message" href="#SetSearchFlags">void SetSearchFlags (int flags)</a></li>
<li><a class="message" href="#GetSearchFlags">int GetSearchFlags()</a></li>
<li><a class="message" href="#SearchInTarget">int SearchInTarget (const wxString& text)</a></li>
<li><a class="message" href="#ReplaceTarget">int ReplaceTarget (const wxString& text)</a></li>
<li><a class="message" href="#ReplaceTargetRE">int ReplaceTargetRE (const wxString& text)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetTargetStart">void SetTargetStart (int pos)</a><br />
    <a name="GetTargetStart">int GetTargetStart()</a></h4>
    <a name="SetTargetEnd">void SetTargetEnd (int pos)</a></h4>
    <a name="GetTargetEnd">int GetTargetEnd()</a></h4>
<p>
Set and return the start and end of the target. When searching in non-regular expression mode, you can set start position greater than end position to find the last matching text in the target rather than the first matching text. The target is also set by a successful <code>SearchInTarget</code>.
</p>

<div class="divider2"></div>
<h4><a name="TargetFromSelection">void TargetFromSelection()</a></h4>
<p>
Set the target start and end to the start and end positions of the current selection.
</p>

<div class="divider2"></div>
<h4><a name="SetSearchFlags">void SetSearchFlags (int flags)</a><br />
    <a name="GetSearchFlags">int GetSearchFlags()</a></h4>
<p>
Set and get the <a class="jump" href="#searchFlags"><code>searchFlags</code></a> used by <code>SearchInTarget</code>. There are several option flags including a simple regular expression search.
</p>

<div class="divider2"></div>
<h4><a name="SearchInTarget">int SearchInTarget (const wxString& text)</a></h4>
<p>
This searches for the first occurrence of a text string in the target defined by <code>SetTargetStart</code> and <code>SetTargetEnd</code>. The text string is not zero terminated; the size is set by <code>length</code>. The search is modified by the search flags set by <code>SetSearchFlags</code>. If the search succeeds, the target is set to the found text and the return value is the position of the start of the matching text. If the search fails, the result is wxSCI_INVALID_POSITION.
</p>

<div class="divider2"></div>
<h4><a name="ReplaceTarget">int ReplaceTarget (const wxString& text)</a></h4>
<p>
After replacement, the target range refers to the replacement text. The return value is the length of the replacement string.
</p>

<div class="divider2"></div>
<h4><a name="ReplaceTargetRE">int ReplaceTargetRE (const wxString& text)</a></h4>
<p>
This replaces the target using regular expressions. The replacement string is formed from the text string with any sequences of <code>\1</code> through <code>\9</code> replaced by tagged matches from the most recent regular expression search. After replacement, the target range refers to the replacement text. The return value is the length of the replacement string.
</p>

<div class="divider1"></div>
<h3 id="Overtype">Overtype</h3>
<p>
</p>

<div class="divider2"></div>
<h4><a name="SetOvertype">void SetOvertype (bool overtype)</a><br />
    <a name="GetOvertype">bool GetOvertype()</a></h4>
<p>
When overtype is enabled, each typed character replaces the character to the right of the text caret. When overtype is disabled, characters are inserted at the caret. <code>GetOvertype</code> returns <code>true</code> if overtyping is active, otherwise <code>false</code>. Use <code>SetOvertype (true)</code> to set the overtype mode.
</p>

<div class="divider1"></div>
<h3 id="CutCopyAndPaste">Cut, copy and paste</h3>

<ul style="list-style-type:none">
<li><a class="message" href="#Cut">void Cut()</a></li>
<li><a class="message" href="#Copy">void Copy()</a></li>
<li><a class="message" href="#Paste">void Paste()</a></li>
<li><a class="message" href="#Clear">void Clear()</a></li>
<li><a class="message" href="#CanPaste">bool CanPaste()</a></li>
<li><a class="message" href="#CopyRange">void CopyRange (int startPos, int endPos)</a></li>
<li><a class="message" href="#CopyText">void CopyText (int length, const wxString& text)</a>
<li><a class="message" href="#SetPasteConvertEndings">void SetPasteConvertEndings (bool convert)
</a><li><a class="message" href="#GetPasteConvertEndings">bool GetPasteConvertEndings ()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="Cut">void Cut()</a><br />
    <a name="Copy">void Copy()</a><br />
    <a name="Paste">void Paste()</a><br />
    <a name="Clear">void Clear()</a><br />
    <a name="CanPaste">bool CanPaste()</a></h4>
<p>
Perform the standard commands of cutting and copying data to the clipboard, pasting from the clipboard into the document, and clearing the document. <code>CanPaste</code> returns true if the document isn't read-only and if the selection doesn't contain protected text. If you need a "can copy" or "can cut", use <code>GetSelectionStart()-GetSelectionEnd()</code>, which will be non-zero if you can copy or cut to the clipboard.
</p>
<p>
GTK+ does not really support <code>CanPaste</code> and always returns <code>true</code> unless the document is read-only.
</p>

<div class="divider2"></div>
<h4><a name="CopyRange">void CopyRange (int startPos, int endPos)</a><br />
    <a name="CopyText">void CopyText (int length, const wxString& text)</a></h4>
<p>
<code>CopyRange</code> copies a range of text from the document to the system clipboard and <code>CopyText</code> copies a supplied piece of text to the system clipboard.
</p>

<div class="divider2"></div>
<h4><a name="SetPasteConvertEndings">void SetPasteConvertEndings (bool convert)</a><br />
    <a name="GetPasteConvertEndings">bool GetPasteConvertEndings ()</a></h4>
<p>
If this property is set then when text is pasted any line ends are converted to match the document's end of line mode as set with <a class="message" href="#SetEOLMode">SetEOLMode</a>. Currently only changeable on Windows. On GTK+ pasted text is always converted.
</p>

<div class="divider1"></div>
<h3 id="ErrorHandling">Error handling</h3>
<p>
</p>

<div class="divider2"></div>
<h4><a name="SetStatus">void SetStatus (int status)</a><br />
    <a name="GetStatus">int GetStatus()</a></h4>
<p>
If an error occurs, Scintilla may set an internal error number that can be retrieved with <code>GetStatus</code>. Not currently used but will be in the future. To clear the error status call <code>SetStatus (0)</code>.
</p>

<div class="divider1"></div>
<h3 id="UndoAndRedo">Undo and Redo</h3>

<p>
Scintilla has multiple level undo and redo. It will continue to collect undoable actions until memory runs out. Scintilla saves actions that change the document. Scintilla does not save caret and selection movements, view scrolling and the like. Sequences of typing or deleting are compressed into single actions to make it easier to undo and redo at a sensible level of detail. Sequences of actions can be combined into actions that are undone as a unit. These sequences occur between <code>BeginUndoAction</code> and <code>EndUndoAction</code>. These sequences can be nested and only the top-level sequences are undone as units.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#Undo">void Undo()</a></li>
<li><a class="message" href="#CanUndo">bool CanUndo()</a></li>
<li><a class="message" href="#Redo">void Redo()</a></li>
<li><a class="message" href="#CanRedo">bool CanRedo()</a></li>
<li><a class="message" href="#EmptyUndoBuffer">void EmptyUndoBuffer()</a></li>
<li><a class="message" href="#SetSavePoint">void SetSavePoint()</a></li>
<li><a class="message" href="#SetUndoCollection">void SetUndoCollection (bool collectUndo)</a></li>
<li><a class="message" href="#GetUndoCollection">bool GetUndoCollection()</a></li>
<li><a class="message" href="#BeginUndoAction">void BeginUndoAction()</a></li>
<li><a class="message" href="#EndUndoAction">void EndUndoAction()</a></li>
<li><a class="message" href="#GetModify">bool GetModify()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="Undo">void Undo()</a></h4>
<p>
<code>Undo</code> undoes one action, or if the undo buffer has reached a <code>EndUndoAction</code> point, all the actions back to the corresponding <code>BeginUndoAction</code>.
</p>

<div class="divider2"></div>
<h4><a name="CanUndo">bool CanUndo()</a></h4>
<p>
<code>CanUndo</code> returns true if there is nothing to undo, otherwise false. You would typically use the result to enable/disable the Edit menu Undo command.
</p>

<div class="divider2"></div>
<h4><a name="Redo">void Redo()</a></h4>
<p>
<code>Redo</code> undoes the effect of the last <code>Undo</code> operation.
</p>

<div class="divider2"></div>
<h4><a name="CanRedo">bool CanRedo()</a></h4>
<p>
<code>CanRedo</code> returns true if there is no action to redo, otherwise false. You could typically use the result to enable/disable the Edit menu Redo command.
</p>

<div class="divider2"></div>
<h4><a name="EmptyUndoBuffer">void EmptyUndoBuffer()</a></h4>
<p>
This command tells Scintilla to forget any saved undo or redo history. It also sets the save point to the start of the undo buffer, so the document will appear to be unmodified. This does not cause the <code><a class="message" href="#wxEVT_SCI_SAVEPOINTREACHED"> CN_SAVEPOINTREACHED</a></code> notification to be sent to the container as
<a class="message" href="#SetSavePoint"><code>SetSavePoint</code></a> does.
</p>

<div class="divider2"></div>
<h4><a name="SetSavePoint">void SetSavePoint()</a></h4>
<p>
Sets the current state of the document to unmodified. This is usually done when the file is saved or loaded, hence the name "save point". As Scintilla performs undo and redo operations, it notifies the container that it has entered or left the save point with <code><a class="message" href="#wxEVT_SCI_SAVEPOINTREACHED">wxEVT_SCI_SAVEPOINTREACHED</a></code> and <code><a class="message" href="#wxEVT_SCI_SAVEPOINTLEFT">wxEVT_SCI_SAVEPOINTLEFT</a></code> <a class="jump" href="#Notifications">notification messages</a>, allowing the container to know if the file should be considered dirty or not.
</p>

<div class="divider2"></div>
<h4><a name="SetUndoCollection">void SetUndoCollection (bool collectUndo)</a><br />
    <a name="GetUndoCollection">bool GetUndoCollection()</a></h4>
<p>
You can control whether Scintilla collects undo information with <code>SetUndoCollection</code>. Pass in <code>true</code> to collect information and <code>false</code> to stop collecting. If you stop collection, you should also use <code>EmptyUndoBuffer</code> to avoid the undo buffer being unsynchronized with the data in the buffer.
</p>
<p>
You might wish to turn off saving undo information if you use the Scintilla to store text generated by a program (a Log view) or in a display window where text is often deleted and regenerated. This can be done with <code>SetUndoCollection (false)</code>.
</p>

<div class="divider2"></div>
<h4><a name="BeginUndoAction">void BeginUndoAction()</a><br />
    <a name="EndUndoAction">void EndUndoAction()</a></h4>
<p>
Mark the beginning and end of a set of operations that you want to undo all as one operation but that you have to generate as several operations. Alternatively, you can use these to mark a set of operations that you do not want to have combined with the preceding or following operations if they are undone.
</p>

<div class="divider2"></div>
<h4><a name="GetModify">bool GetModify()</a></h4>
<p>
Returns true if the document is modified and false if it is unmodified. The modified status of a document is determined by the undo position relative to the save point. The save point is set by <a class="message" href="#SetSavePoint"><code>SetSavePoint</code></a>, usually when you have saved data to a file.
</p>
<p>
If you need to be notified when the document becomes modified, Scintilla notifies the container that it has entered or left the save point with the <a class="message" href="#wxEVT_SCI_SAVEPOINTREACHED"><code>wxEVT_SCI_SAVEPOINTREACHED</code></a> and <a class="message" href="#wxEVT_SCI_SAVEPOINTLEFT"><code>wxEVT_SCI_SAVEPOINTLEFT</code></a> <a class="jump" href="#Notifications">notification messages</a>.
</p>

<div class="divider1"></div>
<h3 id="SelectionAndInformation">Selection and information</h3>

<p>
Scintilla maintains a selection that stretches between two points, the anchor and the current position. If the anchor and the current position are the same, there is no selected text. Positions in the document range from 0 (before the first character), to the document size (after the last character). There is nothing to stop you setting a position that is in the middle of a CRLF pair, or in the middle of a 2 byte character. However, keyboard commands will not move the caret into such positions.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#GetLength">int GetLength()</a></li>
<li><a class="message" href="#GetTextLength">int GetTextLength()</a></li>
<li><a class="message" href="#GetLineCount">int GetLineCount()</a></li>
<li><a class="message" href="#GetFirstVisibleLine">int GetFirstVisibleLine()</a></li>
<li><a class="message" href="#LinesOnScreen">int LinesOnScreen()</a></li>
<li><a class="message" href="#SetSelection">void SetSelection (int startPos, int endPos)</a></li>
<li><a class="message" href="#GotoPos">void GotoPos (int pos)</a></li>
<li><a class="message" href="#GotoLine">void GotoLine (int line)</a></li>
<li><a class="message" href="#SetCurrentPos">void SetCurrentPos (int pos)</a></li>
<li><a class="message" href="#GetCurrentPos">int GetCurrentPos()</a></li>
<li><a class="message" href="#SetAnchor">void SetAnchor (int posAnchor)</a></li>
<li><a class="message" href="#GetAnchor">int GetAnchor()</a></li>
<li><a class="message" href="#SetSelectionStart">void SetSelectionStart (int pos)</a></li>
<li><a class="message" href="#GetSelectionStart">int GetSelectionStart()</a></li>
<li><a class="message" href="#SetSelectionEnd">void SetSelectionEnd (int pos)</a></li>
<li><a class="message" href="#GetSelectionEnd">int GetSelectionEnd()</a></li>
<li><a class="message" href="#SelectAll">void SelectAll()</a></li>
<li><a class="message" href="#LineFromPosition">int LineFromPosition (int pos)</a></li>
<li><a class="message" href="#PositionFromLine">int PositionFromLine (int line)</a></li>
<li><a class="message" href="#GetLineEndPosition">int GetLineEndPosition (int line)</a></li>
<li><a class="message" href="#LineLength">int LineLength (int line)</a></li>
<li><a class="message" href="#GetColumn">int GetColumn (int pos)</a></li>
<li><a class="message" href="#FindColumn">int FindColumn (int line, int column)</a></li>
<li><a class="message" href="#PositionFromPoint">int PositionFromPoint (wxPoint pt)</a></li>
<li><a class="message" href="#PositionFromPointClose">int PositionFromPointClose (int x, int y)</a></li>
<li><a class="message" href="#PointXFromPosition">PointXFromPosition: Currently not implemented!</a></li>
<li><a class="message" href="#PointYFromPosition">PointYFromPosition: Currently not implemented!</a></li>
<li><a class="message" href="#HideSelection">void HideSelection (bool hide)</a></li>
<li><a class="message" href="#GetSelectedText">wxString GetSelectedText()</a></li>
<li><a class="message" href="#GetCurLine">wxString GetCurLine (int* linePos = NULL)</a></li>
<li><a class="message" href="#SelectionIsRectangle">bool SelectionIsRectangle()</a></li>
<li><a class="message" href="#SetSelectionMode">void SetSelectionMode (int mode)</a></li>
<li><a class="message" href="#GetSelectionMode">int GetSelectionMode()</a></li>
<li><a class="message" href="#GetLineSelStartPosition">int GetLineSelStartPosition (int line)</a></li>
<li><a class="message" href="#GetLineSelEndPosition">int GetLineSelEndPosition (int line)</a></li>
<li><a class="message" href="#MoveCaretInsideView">void MoveCaretInsideView()</a></li>
<li><a class="message" href="#WordStartPosition">int WordStartPosition (int pos, bool onlyWordCharacters)</a></li>
<li><a class="message" href="#WordEndPosition">int WordEndPosition (int pos, bool onlyWordCharacters)</a></li>
<li><a class="message" href="#PositionBefore">int PositionBefore (int pos)</a></li>
<li><a class="message" href="#PositionAfter">int PositionAfter (int pos)</a></li>
<li><a class="message" href="#TextWidth">int TextWidth (int style, const wxString& text)</a></li>
<li><a class="message" href="#TextHeight">int TextHeight (int line)</a></li>
<li><a class="message" href="#ChooseCaretX">void ChooseCaretX()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="GetLength">int GetLength()</a><br />
    <a name="GetTextLength">int GetTextLength()</a></h4>
<p>
Return the length of the document in characters. The use of GetLength is prefered.
</p>

<div class="divider2"></div>
<h4><a name="GetLineCount">int GetLineCount()</a></h4>
<p>
Returns the number of lines in the document. An empty document contains 1 line. A document holding only an end of line sequence has 2 lines.
</p>

<div class="divider2"></div>
<h4><a name="GetFirstVisibleLine">int GetFirstVisibleLine()</a></h4>
<p>
Returns the line number of the first visible line in the Scintilla view. The first line in the document is numbered 0.
</p>

<div class="divider2"></div>
<h4><a name="LinesOnScreen">int LinesOnScreen()</a></h4>
<p>
Returns the number of complete lines visible on the screen. With a constant line height, this is the vertical space available divided by the line separation. Unless you arrange to size your window to an integral number of lines, there may be a partial line visible at the bottom of the view.
</p>

<div class="divider2"></div>
<h4><a name="SetSelection">void SetSelection (int startPos, int endPos)</a></h4>
<p>
Sets both the anchor (<code>startPos</code>) and the current position (<code>endPos</code>) and selects the text. If <code>endPos</code> is negative, it means the end of the document. If <code>startPos</code> is negative, it means remove any selection (i.e. set the anchor to the same position as <code>currentPos</code>). The caret is scrolled into view after this operation.
</p>

<div class="divider2"></div>
<h4><a name="GotoPos">void GotoPos (int pos)</a></h4>
<p>
Sets the caret at <code>pos</code>, removes any selection and scrolls the view to make the caret visible, if necessary. It is equivalent to <code>SetSelection (pos, pos)</code>. The anchor position is set the same as the current position.
</p>

<div class="divider2"></div>
<h4><a name="GotoLine">void GotoLine (int line)</a></h4>
<p>
Sets the caret at the start of line number <code>line</code>, removes any selection and scrolls the view (if needed) to make it visible. The anchor position is set the same as the current position. If <code>line</code> is outside the lines in the document (first line is 0), the line set is the first or last.
</p>

<div class="divider2"></div>
<h4><a name="SetCurrentPos">void SetCurrentPos (int pos)</a></h4>
<p>
Sets the current position and creates a selection between the anchor and the current position. The caret is not scrolled into view.
</p>
<p>
See also: <a class="message" href="#EnsureCaretVisible"><code>EnsureCaretVisible</code></a>
</p>

<div class="divider2"></div>
<h4><a name="GetCurrentPos">int GetCurrentPos()</a></h4>
<p>
This returns the current position.
</p>

<div class="divider2"></div>
<h4><a name="SetAnchor">void SetAnchor (int posAnchor)</a></h4>
<p>
This sets the anchor position and creates a selection between the anchor position and the current position. The caret is not scrolled into view.
</p>
<p>
See also: <a class="message" href="#EnsureCaretVisible"><code>EnsureCaretVisible</code></a>
</p>

<div class="divider2"></div>
<h4><a name="GetAnchor">int GetAnchor()</a></h4>
<p>
Returns the current anchor position.
</p>

<div class="divider2"></div>
<h4><a name="SetSelectionStart">void SetSelectionStart (int pos)</a><br />
    <a name="SetSelectionEnd">void SetSelectionEnd (int pos)</a></h4>
<p>
Set the selection based on the assumption that the anchor position is less than the current position. They do not make the caret visible. The table shows the positions of the anchor and the current position after using either.
</p>
<table cellpadding="3" cellspacing="0" border="1" summary="SetSelection caret positioning"><thead align="center">
<tr>
  <th></th>
  <th>anchor</th>
  <th>current</th>
</tr></thead><tbody align="left">
<tr>
  <th><code>SetSelectionStart</code></th>
  <td><code>pos</code></td>
  <td><code>Max(pos, current)</code></td>
</tr><tr>
  <th><code>SetSelectionEnd</code></th>
  <td><code>Min(anchor, pos)</code></td>
  <td><code>pos</code></td>
</tr>
</tbody></table>
<p>
See also: <a class="message" href="#EnsureCaretVisible"><code>EnsureCaretVisible</code></a>
</p>

<div class="divider2"></div>
<h4><a name="GetSelectionStart">int GetSelectionStart()</a><br />
    <a name="GetSelectionEnd">int GetSelectionEnd()</a></h4>
<p>
Return the start and end of the selection without regard to which end is the current position and which is the anchor. <code>GetSelectionStart</code> returns the smaller of the current position or the anchor position. <code>GetSelectionEnd</code> returns the larger of the two values.
</p>

<div class="divider2"></div>
<h4><a name="SelectAll">void SelectAll()</a></h4>
<p>
This selects all the text in the document. The current position is not scrolled into view.
</p>

<div class="divider2"></div>
<h4><a name="LineFromPosition">int LineFromPosition (int pos)</a></h4>
<p>
Returns the line that contains the position <code>pos</code> in the document. The return value is 0 if <code>pos</code> &lt;= 0. The return value is the last line if <code>pos</code> is beyond the end of the document.
</p>

<div class="divider2"></div>
<h4><a name="PositionFromLine">int PositionFromLine (int line)</a></h4>
<p>
Returns the document position that corresponds with the start of the line. If <code>line</code> is negative, the position of the line holding the start of the selection is returned. If <code>line</code> is greater than the lines in the document, the return value is wxSCI_INVALID_POSITION. If <code>line</code> is equal to the number of lines in the document (i.e. 1 line past the last line), the return value is the end of the document.
</p>

<div class="divider2"></div>
<h4><a name="GetLineEndPosition">int GetLineEndPosition (int line)</a></h4>
<p>
Returns the position at the end of the line, before any line end characters. If <code>line</code> is negative, the result is 0. If <code>line</code> is the last line in the document, (which does not have any end of line characters), the result is the size of the document. If <code>line</code> is negative, the result is wxSCI_INVALID_POSITION. If <code>line</code> is &gt;= <code>GetLineCount()</code>, the result is currently <code>GetLength()-1</code>.
</p>

<div class="divider2"></div>
<h4><a name="LineLength">int LineLength (int line)</a></h4>
<p>
Returns the length of the line, including any line end characters. If <code>line</code> is negative or beyond the last line in the document, the result is 0. If you want the length of the line not including any end of line characters, use <a class="message" href="#GetLineEndPosition"><code>GetLineEndPosition(line)</code></a> - <a class="message" href="#PositionFromLine"><code>PositionFromLine(line)</code></a>.
</p>

<div class="divider2"></div>
<h4><a name="GetSelectedText">wxString GetSelectedText()</a></h4>
<p>
Returns the currently selected text.
</p>
<p>
See also: <code><a class="message" href="#GetCurLine">GetCurLine</a>, <a class="message" href="#GetLine">GetLine</a>, <a class="message" href="#GetText">GetText</a>, <a class="message" href="#GetStyledText">GetStyledText</a>, <a class="message" href="#GetTextRange">GetTextRange</a></code>
</p>

<div class="divider2"></div>
<h4><a name="GetCurLine">wxString GetCurLine (int* linePos = NULL)</a></h4>
<p>
Retrieves the text of the line containing the caret and returns the position within the line of the caret.
</p>
<p>
See also: <code><a class="message" href="#GetSelectedText">GetSelectedText</a>, <a class="message" href="#GetLine">GetLine</a>, <a class="message" href="#GetText">GetText</a>, <a class="message" href="#GetStyledText">GetStyledText</a>, <a class="message" href="#GetTextRange">GetTextRange</a></code>
</p>

<div class="divider2"></div>
<h4><a name="SelectionIsRectangle">bool SelectionIsRectangle()</a></h4>
<p>
Returns true if the current selection is in rectangle mode, false if not.
</p>

<div class="divider2"></div>
<h4><a name="SetSelectionMode">void SetSelectionMode (int mode)</a><br />
    <a name="GetSelectionMode">int GetSelectionMode()</a></h4>
<p>
Set and get the selection mode, which can be stream (<code>wxSCI_SEL_STREAM</code>=1, default) or rectangular (<code>wxSCI_SEL_RECTANGLE</code>=2) or by lines (<code>wxSCI_SEL_LINES</code>=3). When set in these modes, regular caret moves will extend or reduce the selection, until the mode is cancelled by a call with same value or with <code>Cancel</code>. The get function returns the current mode even if the selection was made by mouse or with regular extended moves.
</p>

<div class="divider2"></div>
<h4><a name="GetLineSelStartPosition">int GetLineSelStartPosition (int line)</a><br />
    <a name="GetLineSelEndPosition">int GetLineSelEndPosition (int line)</a></h4>
<p>
Retrieve the position of the start and end of the selection at the given line with wxSCI_INVALID_POSITION returned if no selection on this line.
</p>

<div class="divider2"></div>
<h4><a name="MoveCaretInsideView">void MoveCaretInsideView()</a></h4>
<p>
If the caret is off the top or bottom of the view, it is moved to the nearest line that is visible to its current position. Any selection is lost.
</p>

<div class="divider2"></div>
<h4><a name="WordStartPosition">int WordStartPosition (int pos, bool onlyWordCharacters)</a><br />
    <a name="WordEndPosition">int WordEndPosition (int pos, bool onlyWordCharacters)</a></h4>
<p>
Return the start and end of words using the same definition of words as used internally within Scintilla. You can set your own list of characters that count as words with <a class="message" href="#SetWordChars"><code>SetWordChars</code></a>. The position sets the start or the search, which is forwards when searching for the end and backwards when searching for the start.
</p>
<p>
Set <code>onlyWordCharacters</code> to <code>true</code> to stop searching at the first non-word character in the search direction. If <code>onlyWordCharacters</code> is <code> false</code>, the first character in the search direction sets the type of the search as word or non-word and the search stops at the first non-matching character. Searches are also terminated by the start or end of the document.
</p>
<p>
If "w" represents word characters and "." represents non-word characters and "|" represents the position and <code>true</code> or <code>false</code> is the state of <code>onlyWordCharacters</code>:
</p>
<table cellpadding="3" cellspacing="0" border="1" summary="Word start and end positions">  <thead align="center">
<tr>
  <th>Initial state</th>
  <th>end, true</th>
  <th>end, false</th>
  <th>start, true</th>
  <th>start, false</th>
</tr></thead>
<tbody align="center">
<tr>
  <td>..ww..|..ww..</td>
  <td>..ww..|..ww..</td>
  <td>..ww....|ww..</td>
  <td>..ww..|..ww..</td>
  <td>..ww|....ww..</td>
</tr><tr>
  <td>....ww|ww....</td>
  <td>....wwww|....</td>
  <td>....wwww|....</td>
  <td>....|wwww....</td>
  <td>....|wwww....</td>
</tr><tr>
  <td>..ww|....ww..</td>
  <td>..ww|....ww..</td>
  <td>..ww....|ww..</td>
  <td>..|ww....ww..</td>
  <td>..|ww....ww..</td>
</tr><tr>
  <td>..ww....|ww..</td>
  <td>..ww....ww|..</td>
  <td>..ww....ww|..</td>
  <td>..ww....|ww..</td>
  <td>..ww|....ww..</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="PositionBefore">int PositionBefore (int pos)</a><br />
    <a name="PositionAfter">int PositionAfter (int pos)</a></h4>
<p>
Returns the position before and after another position  in the document taking into account the current code page. The minimum position returned is 0 and the maximum is the last position in the document. If called with a position within a multi byte character will return the position of the start/end of that character.
</p>

<div class="divider2"></div>
<h4><a name="TextWidth">int TextWidth (int style, const wxString& text)</a></h4>
<p>
Returns the pixel width of a string drawn in the given <code>styleNumber</code> which can be used, for example, to decide how wide to make the line number margin in order to display a given number of numerals.
</p>

<div class="divider2"></div>
<h4><a name="TextHeight">int TextHeight (int line)</a></h4>
<p>
Returns the height in pixels of a particular line. Currently all lines are the same height.
</p>

<div class="divider2"></div>
<h4><a name="GetColumn">int GetColumn (int pos)</a></h4>
<p>
Returns the column number of a position <code>pos</code> within the document taking the width of tabs into account. This returns the column number of the last TAB on the line before <code>pos</code>, plus the number of characters between the last TAB and <code>pos</code>. If there are no TAB characters on the line, the return value is the number of characters up to the position on the line. In both cases, double byte characters count as a single character. This is probably only useful with monospaced fonts.
</p>

<div class="divider2"></div>
<h4><a name="FindColumn">int FindColumn (int line, int column)</a></h4>
<p>
Returns the position of a <code>column</code> on a <code>line</code> taking the width of tabs into account. It treats a multi-byte character as a single column. Column numbers, like lines start at 0.
</p>

<div class="divider2"></div>
<h4><a name="PositionFromPoint">int PositionFromPoint (wxPoint pt)</a><br />
    <a name="PositionFromPointClose">int PositionFromPointClose (int x, int y)</a></h4>
<p>
<code>PositionFromPoint</code> finds the closest character position to a point and <code>PositionFromPointClose</code> is similar but returns wxSCI_INVALID_POSITION if the point is outside the window or not close to any characters.
</p>

<div class="divider2"></div>
<h4><a name="HideSelection">void HideSelection (bool hide)</a></h4>
<p>
The normal state is to make the selection visible by drawing it as set by <a class="message" href="#SetSelForeground"><code>SetSelForeground</code></a> and <a class="message" href="#SetSelBackground"><code>SetSelBackground</code></a>. However, if you hide the selection, it is drawn as normal text.
</p>

<div class="divider2"></div>
<h4><a name="ChooseCaretX">void ChooseCaretX()</a></h4>
<p>
Scintilla remembers the x value of the last position horizontally moved to explicitly by the user and this value is then used when moving vertically such as by using the up and down keys. Sets the current x position of the caret as the remembered value.
</p>

<div class="divider1"></div>
<h3 id="ScrollingAndAutomaticScrolling">Scrolling and automatic scrolling</h3>

<ul style="list-style-type:none">
<li><a class="message" href="#LineScroll">void LineScroll (int columns, int lines)</a></li>
<li><a class="message" href="#EnsureCaretVisible">void EnsureCaretVisible()</a></li>
<li><a class="message" href="#SetXCaretPolicy">void SetXCaretPolicy (int caretPolicy, int caretSlop)</a></li>
<li><a class="message" href="#SetYCaretPolicy">void SetYCaretPolicy (int caretPolicy, int caretSlop)</a></li>
<li><a class="message" href="#SetVisiblePolicy">void SetVisiblePolicy (int visiblePolicy, int visibleSlop)</a></li>
<li><a class="message" href="#SetUseHorizontalScrollBar">void SetUseHorizontalScrollBar (bool show)</a></li>
<li><a class="message" href="#GetUseHorizontalScrollBar">bool GetUseHorizontalScrollBar()</a></li>
<li><a class="message" href="#SetUseVerticalScrollBar">void SetUseVerticalScrollBar (bool show)</a></li>
<li><a class="message" href="#GetUseVerticalScrollBar">bool GetUseVerticalScrollBar()</a></li>
<li><a class="message" href="#GetXOffset">int GetXOffset()</a></li>
<li><a class="message" href="#SetXOffset">void SetXOffset (int newOffset)</a></li>
<li><a class="message" href="#SetScrollWidth">void SetScrollWidth (int pixels)</a></li>
<li><a class="message" href="#GetScrollWidth">int GetScrollWidth()</a></li>
<li><a class="message" href="#SetEndAtLastLine">void SetEndAtLastLine (bool endAtLastLine)</a></li>
<li><a class="message" href="#GetEndAtLastLine">int GetEndAtLastLine()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="LineScroll">void LineScroll (int columns, int lines)</a></h4>
<p>
Attempts to scroll the display by the number of columns and lines that you specify. Positive line values increase the line number at the top of the screen (i.e. they move the text upwards as far as the user is concerned), Negative line values do the reverse.
</p>
<p>
The column measure is the width of a space in the default style. Positive values increase the column at the left edge of the view (i.e. they move the text leftwards as far as the user is concerned). Negative values do the reverse.
</p>
<p>
See also: <code><a class="message" href="#SetXOffset">SetXOffset</code></a>
</p>

<div class="divider2"></div>
<h4><a name="EnsureCaretVisible">void EnsureCaretVisible()</a></h4>
<p>
If the current position (this is the caret if there is no selection) is not visible, the view is scrolled to make it visible according to the current caret policy.
</p>

<div class="divider2"></div>
<h4><a name="SetXCaretPolicy">void SetXCaretPolicy (int caretPolicy, int caretSlop)</a><br />
    <a name="SetYCaretPolicy">void SetYCaretPolicy (int caretPolicy, int caretSlop)</a></h4>
<p>
Set the caret policy. The value of <code>caretPolicy</code> is a combination of <code>wxSCI_CARET_SLOP</code>, <code>wxSCI_CARET_STRICT</code>, <code>wxSCI_CARET_JUMPS</code> and <code>wxSCI_CARET_EVEN</code>.
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Caret policy"> <tbody valign="top">
<tr>
  <th align="left"><code>wxSCI_CARET_SLOP</code></th>
  <td>If set, we can define a slop value: <code>caretSlop</code>. This value defines an   unwanted zone (UZ) where the caret is... unwanted. This zone is defined as a number of   pixels near the vertical margins, and as a number of lines near the horizontal margins.   By keeping the caret away from the edges, it is seen within its context. This makes it   likely that the identifier that the caret is on can be completely seen, and that the   current line is seen with some of the lines following it, which are often dependent on   that line.</td>
</tr><tr>
  <th align="left"><code>wxSCI_CARET_STRICT</code></th>
  <td>If set, the policy set by <code>wxSCI_CARET_SLOP</code> is enforced... strictly. The  caret is centered on the display if <code>caretSlop</code> is not set, and cannot go in the UZ if <code>caretSlop</code> is set.</td>
</tr><tr>
  <th align="left"><code>wxSCI_CARET_JUMPS</code></th>
  <td>If set, the display is moved more energetically so the caret can move in the same   direction longer before the policy is applied again. '3UZ' notation is used to indicate   three time the size of the UZ as a distance to the margin.</td>
</tr><tr>
  <th align="left"><code>wxSCI_CARET_EVEN</code></th>
  <td>If not set, instead of having symmetrical UZs, the left and bottom UZs are extended   up to right and top UZs respectively. This way, we favour the displaying of useful   information: the beginning of lines, where most code resides, and the lines after the   caret, for example, the body of a function.</td>
</tr>
</tbody></table>

<table cellpadding="3" cellspacing="0" border="1" summary="Caret positioning"><thead align="center">
<tr>
  <th>slop</th>
  <th>strict</th>
  <th>jumps</th>
  <th>even</th>
  <th>Caret can go to the margin</th>
  <th>On reaching limit (going out of visibility<br />
   or going into the UZ) display is...</th>
</tr></thead>
<tbody align="center">
<tr>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>Yes</td>
  <td>moved to put caret on top/on right</td>
</tr><tr>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>1</td>
  <td>Yes</td>
  <td>moved by one position</td>
</tr><tr>
  <td>0</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>Yes</td>
  <td>moved to put caret on top/on right</td>
</tr><tr>
  <td>0</td>
  <td>0</td>
  <td>1</td>
  <td>1</td>
  <td>Yes</td>
  <td>centered on the caret</td>
</tr><tr>
  <td>0</td>
  <td>1</td>
  <td>-</td>
  <td>0</td>
  <td>Caret is always on top/on right of display</td>
  <td>-</td>
</tr><tr>
  <td>0</td>
  <td>1</td>
  <td>-</td>
  <td>1</td>
  <td>No, caret is always centered</td>
  <td>-</td>
</tr><tr>
  <td>1</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>Yes</td>
  <td>moved to put caret out of the asymmetrical UZ</td>
</tr><tr>
  <td>1</td>
  <td>0</td>
  <td>0</td>
  <td>1</td>
  <td>Yes</td>
  <td>moved to put caret out of the UZ</td>
</tr><tr>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>Yes</td>
  <td>moved to put caret at 3UZ of the top or right margin</td>
</tr><tr>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>1</td>
  <td>Yes</td>
  <td>moved to put caret at 3UZ of the margin</td>
</tr><tr>
  <td>1</td>
  <td>1</td>
  <td>-</td>
  <td>0</td>
  <td>Caret is always at UZ of top/right margin</td>
  <td>-</td>
</tr><tr>
  <td>1</td>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>No, kept out of UZ</td>
  <td>moved by one position</td>
</tr>
<tr>
  <td>1</td>
  <td>1</td>
  <td>1</td>
  <td>0</td>
  <td>No, kept out of UZ</td>
  <td>moved to put caret at 3UZ of the margin</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="SetVisiblePolicy">void SetVisiblePolicy (int visiblePolicy, int visibleSlop)</a></h4>
<p>
Determines how the vertical positioning is determined when <a class="message" href="#EnsureVisibleEnforcePolicy"><code>EnsureVisibleEnforcePolicy</code></a> is called. It takes <code>wxSCI_VISIBLE_SLOP</code> and <code>wxSCI_VISIBLE_STRICT</code> flags for the policy parameter. It is similar in operation to <a class="message" href="#SetYCaretPolicy"><code>SetYCaretPolicy(int caretPolicy, int caretSlop)</code></a>.
</p>

<div class="divider2"></div>
<h4><a name="SetUseHorizontalScrollBar">void SetUseHorizontalScrollBar (bool show)</a><br />
    <a name="GetUseHorizontalScrollBar">bool GetUseHorizontalScrollBar()</a></h4>
<p>
The horizontal scroll bar is only displayed if it is needed for the assumed width. If you never wish to see it, call <code>SetUseHorizontalScrollBar (false)</code>. Use <code> SetUseHorizontalScrollBar (true)</code> to enable it again. <code>GetUseHorizontalScrollBar</code> returns the current state. The default state is to  display it when needed.
</p>
<p>
See also: <code><a class="message" href="#SetScrollWidth">SetScrollWidth</a></code>.
</p>

<div class="divider2"></div>
<h4><a name="SetUseVerticalScrollBar">void SetUseVerticalScrollBar (bool show)</a><br />
    <a name="GetUseVerticalScrollBar">bool GetUseVerticalScrollBar()</a></h4>
<p>
By default, the vertical scroll bar is always displayed when required. You can choose to hide or show it with <code>SetUseVerticalScrollBar</code> and get the current state with <code>GetUseVerticalScrollBar</code>.
</p>

<div class="divider2"></div>
<h4><a name="SetXOffset">void SetXOffset (int newOffset)</a><br />
    <a name="GetXOffset">int GetXOffset()</a></h4>
<p>
The <code>newOffset</code> is the horizontal scroll position in pixels of the start of the text view. A value of 0 is the normal position with the first text column visible at the left of the view.
</p>
<p>
See also: <a class="message" href="#LineScroll"><code>LineScroll</code></a>
</p>

<div class="divider2"></div>
<h4><a name="SetScrollWidth">void SetScrollWidth (int pixels)</a><br />
    <a name="GetScrollWidth">int GetScrollWidth()</a></h4>
<p>
For performance, Scintilla does not measure the width of the document to determine  the properties of the horizontal scroll bar. Instead, an assumed width (2000 pixels) is used. Set and get the document width in pixels so Scintilla can adjust the horizontal scroll bar accordingly.
</p>

<div class="divider2"></div>
<h4><a name="SetEndAtLastLine">void SetEndAtLastLine (bool endAtLastLine)</a><br />
    <a name="GetEndAtLastLine">int GetEndAtLastLine()</a></h4>
<p>
<code>SetEndAtLastLine</code> sets the scroll range so that maximum scroll position has the last line at the bottom of the view (default). Setting this to <code>false</code> allows scrolling one page below the last line.
</p>

<div class="divider1"></div>
<h3 id="WhiteSpace">White space</h3>

<ul style="list-style-type:none">
<li><a class="message" href="#SetViewWhiteSpace">void SetViewWhiteSpace (int viewWS)</a></li>
<li><a class="message" href="#GetViewWhiteSpace">int GetViewWhiteSpace()</a></li>
<li><a class="message" href="#SetWhitespaceForeground">void SetWhitespaceForeground (bool useSetting, const wxColour& fore)</a></li>
<li><a class="message" href="#SetWhitespaceBackground">void SetWhitespaceBackground (bool useSetting, const wxColour& back)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetViewWhiteSpace">void SetViewWhiteSpace (int viewWS)</a><br />
    <a name="GetViewWhiteSpace">int GetViewWhiteSpace()</a></h4>
<p>
White space can be made visible which may useful for languages in which white space is significant, such as Python. Space characters appear as small centered dots and TAB characters as light arrows pointing to the right. There are also ways to control the display of <a class="jump" href="#LineEndings">end of line characters</a>. Set and get the white space display mode. The <code>viewWS</code> argument can be one of:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="White space policy"><tbody valign="top">
<tr>
  <th align="left"><code>wxSCI_WS_INVISIBLE</code></th>
  <td>0</td>
  <td>The normal display mode with white space displayed as an empty background colour.</td>
</tr><tr>
  <th align="left"><code>wxSCI_WS_VISIBLEALWAYS</code></th>
  <td>1</td>
  <td>White space characters are drawn as dots and arrows,</td>
</tr><tr>
  <th align="left"><code>wxSCI_WS_VISIBLEAFTERINDENT</code></th>
  <td>2</td>
  <td>White space used for indentation is displayed normally but after the first visible  character, it is shown as dots and arrows.</td>
</tr>
</tbody></table>
<p>
The effect of using any other <code>wsMode</code> value is undefined.
</p>

<div class="divider2"></div>
<h4><a name="SetWhitespaceForeground">void SetWhitespaceForeground (bool useSetting, const wxColour& fore)</a><br/>
    <a name="SetWhitespaceBackground">void SetWhitespaceBackground (bool useSetting, const wxColour& back)</a></h4>
<p>
By default, the colour of visible white space is determined by the lexer in use. The foreground and/or background colour of all visible white space can be set globally, overriding the lexer's colours with <code>SetWhitespaceForeground</code> and <code>SetWhitespaceBackground</code>.
</p>

<div class="divider1"></div>
<h3 id="Cursor">Cursor</h3>
<p>
</p>

<div class="divider2"></div>
<h4><a name="SetCursorType">void SetCursorType (int cursorType)</a><br />
    <a name="GetCursorType">int GetCursorType()</a></h4>
<p>
The cursor is normally chosen in a context sensitive way, so it will be different over the margin than when over the text. When performing a slow action, you may wish to change to a wait cursor. You set the cursor type with <code>SetCursorType</code>. The <code>curType</code> argument can be:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Mouse cursors"><tbody valign="top">
<tr>
  <th align="left"><code>wxSCI_CURSORNORMAL</code></th>
  <td>-1</td>
  <td>The normal cursor is displayed.</td>
</tr><tr>
  <th align="left"><code>wxSCI_CURSORWAIT</code></th>
  <td>&nbsp;4</td>
  <td>The wait cursor is displayed when the mouse is over or owned by the Scintilla   window.</td>
</tr>
</tbody></table>
<p>
Cursor values 1 through 7 have defined cursors, but only <code>wxSCI_CURSORWAIT</code> is usefully controllable. Other values of <code>curType</code> cause a pointer to be displayed. The <code>GetCursorType</code> returns the last cursor type you set, or <code>wxSCI_CURSORNORMAL</code> if you have not set a cursor type.
</p>

<div class="divider1"></div>
<h3 id="MouseCapture">Mouse capture</h3>
<p>
</p>

<div class="divider2"></div>
<h4><a name="SetMouseDownCaptures">void SetMouseDownCaptures (bool captures)</a><br />
    <a name="GetMouseDownCaptures">bool GetMouseDownCaptures()</a></h4>
<p>
When the mouse is pressed inside Scintilla, it is captured so future mouse movement events are sent to Scintilla. This behavior may be turned off with <code>SetMouseDownCaptures (false)</code>.
</p>

<div class="divider1"></div>
<h3 id="LineEndings">Line endings</h3>

<p>
Scintilla can interpret any of the three major line end conventions, Macintosh (\r), Unix (\n) and CP/M / DOS / Windows (\r\n). When the user presses the Enter key, one of these line end strings is inserted into the buffer. The default is \r\n in Windows and \n in Unix, but this can be changed with the <code>SetEOLMode</code>. You can also convert the entire document to one of these line endings with <code>ConvertEOLs</code>. Finally, you can choose to display the line endings with <code>SetViewEOL</code>.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#SetEOLMode">void SetEOLMode (int eolMode)</a></li>
<li><a class="message" href="#GetEOLMode">int GetEOLMode()</a></li>
<li><a class="message" href="#ConvertEOLs">void ConvertEOLs (int eolMode)</a></li>
<li><a class="message" href="#SetViewEOL">void SetViewEOL (bool visible))</a></li>
<li><a class="message" href="#GetViewEOL">bool GetViewEOL()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetEOLMode">void SetEOLMode (int eolMode)</a><br />
    <a name="GetEOLMode">int GetEOLMode()</a></h4>
<p>
<code>SetEOLMode</code> sets the characters that are added into the document when the user presses the Enter key. You can set <code>eolMode</code> to one of <code>wxSCI_EOL_CRLF</code> (0), <code>wxSCI_EOL_CR</code> (1), or <code>wxSCI_EOL_LF</code> (2). The <code>GetEOLMode</code> retrieves the current state.
</p>

<div class="divider2"></div>
<h4><a name="ConvertEOLs">void ConvertEOLs (int eolMode)</a></h4>
<p>
Changes all the end of line characters in the document to match <code>eolMode</code>. Valid values are: <code>wxSCI_EOL_CRLF</code> (0), <code>wxSCI_EOL_CR</code> (1), or <code>wxSCI_EOL_LF</code> (2).
</p>

<div class="divider2"></div>
<h4><a name="SetViewEOL">void SetViewEOL (bool visible)</a><br />
    <a name="GetViewEOL">bool GetViewEOL()</a></h4>
<p>
Normally, the end of line characters are hidden, but <code>SetViewEOL</code> allows you to display (or hide) them by setting <code>visible</code> <code>true</code> (or <code>false</code>). The visible rendering of the end of line characters is similar to <code>(CR)</code>, <code>(LF)</code>, or <code>(CR)(LF)</code>. <code>GetViewEOL</code> returns the current state.
</p>

<div class="divider1"></div>
<h3 id="Styling">Styling</h3>

<p>
The styling allow you to assign styles to text. The standard Scintilla settings divide the 8 style bits available for each character into 5 bits (0 to 4 = <a class="jump" href="#StyleDefinition">styles 0 to 31</a>) that set a style and three bits (5 to 7) that define <a class="jump" href="#Indicators">indicators</a>. You can change the balance between styles and indicators with <a class="message" href="#SetStyleBits"><code>SetStyleBits</code></a>. If your styling needs can be met by one of the standard lexers, or if you can write your own, then a lexer is probably the easiest way to style your document. If you choose to use the container to do the styling you can use the <a class="message" href="#SetLexer"><code>SetLexer</code></a> command to select <code>wxSCI_LEX_CONTAINER</code>, in which case the container is sent a <a class="message" href="#wxEVT_SCI_STYLENEEDED"><code>wxEVT_SCI_STYLENEEDED</code></a> <a class="jump" href="#Notifications">notification</a> each time text needs styling for display. As another alternative, you might use idle time to style the document. Even if you use a lexer, you might use the styling commands to mark errors detected by a compiler. The following commands can be used.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#GetEndStyled">int GetEndStyled()</a></li>
<li><a class="message" href="#StartStyling">void StartStyling (int pos, int mask)</a></li>
<li><a class="message" href="#SetStyling">void SetStyling (int length, int style)</a></li>
<li><a class="message" href="#SetStyleBytes">void SetStyleBytes (int length, char* styleBytes)</a></li>
<li><a class="message" href="#SetLineState">void SetLineState (int line, int state)</a></li>
<li><a class="message" href="#GetLineState">int GetLineState (int line)</a></li>
<li><a class="message" href="#GetMaxLineState">int GetMaxLineState()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="GetEndStyled">int GetEndStyled()</a></h4>
<p>
Scintilla keeps a record of the last character that is likely to be styled correctly. This is moved forwards when characters after it are styled and moved backwards if changes are made to the text of the document before it. Before drawing text, this position is checked to see if any styling is needed and, if so, a <code><a class="message" href="#wxEVT_SCI_STYLENEEDED">wxEVT_SCI_STYLENEEDED</a></code> notification message is sent to the container. The container can send <code>GetEndStyled</code> to work out where it needs to start styling. Scintilla will always ask to style whole lines.
</p>

<div class="divider2"></div>
<h4><a name="StartStyling">void StartStyling (int pos, int mask)</a></h4>
<p>
This prepares for styling by setting the styling position <code>pos</code> to start at and a <code>mask</code> indicating which bits of the style bytes can be set. The mask allows styling to occur over several passes, with, for example, basic styling done on an initial pass to ensure that the text of the code is seen quickly and correctly, and then a second slower pass, detecting syntax errors and using indicators to show where these are. For example, with the standard settings of 5 style bits and 3 indicator bits, you would use a <code>mask</code> value of 31 (0x1f) if you were setting text styles and did not want to change the indicators. After <code>StartStyling</code>, send multiple <code>SetStyling</code> for each lexical entity to style.
</p>

<div class="divider2"></div>
<h4><a name="SetStyling">void SetStyling (int length, int style)</a></h4>
<p>
Sets the style of <code>length</code> characters starting at the styling position and then increases the styling position by <code>length</code>, ready for the next call. If <code>sCell</code> is the style byte, the operation is:<br />
<code>if ((sCell &amp; mask) != style) sCell = (sCell &amp; ~mask) | (style &amp; mask);</code><br />
</p>

<div class="divider2"></div>
<h4><a name="SetStyleBytes">void SetStyleBytes (int length, char* styleBytes)</a></h4>
<p>
As an alternative to <code>SetStyling</code>, which applies the same style to each byte, you can use this which specifies the styles for each of <code>length</code> bytes from the styling position and then increases the styling position by <code>length</code>, ready for the next call. The <code>length</code> styling bytes pointed at by <code>styles</code> should not contain any bits not set in mask.
</p>

<div class="divider2"></div>
<h4><a name="SetLineState">void SetLineState (int line, int state)</a><br />
    <a name="GetLineState">int GetLineState (int line)</a></h4>
<p>
As well as the 8 bits of lexical state stored for each character there is also an integer stored for each line. This can be used for longer lived parse states such as what the current scripting language is in an ASP page. Use <code>SetLineState</code> to set the integer value and <code>GetLineState</code> to get the value.
</p>

<div class="divider2"></div>
<h4><a name="GetMaxLineState">int GetMaxLineState()</a></h4>
<p>
Returns the last line that has any line state.
</p>

<div class="divider1"></div>
<h3 id="StyleDefinition">Style definition</h3>

<p>
While the style setting mentioned above change the style numbers associated with text, these define how those style numbers are interpreted visually. There are 128 lexer styles that can be set, numbered 0 to <code>STYLEMAX</code> (127). Unless you use <a class="message" href="#SetStyleBits"><code>SetStyleBits</code></a> to change the number of style bits, styles 0 to 31 are used to set the text attributes. There are also some predefined numbered styles starting at 32, The following <code>wxSCI_STYLE_...</code> constants are defined.
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Preset styles"><tbody valign="top">
<tr>
  <th align="left"><code>wxSCI_STYLE_DEFAULT</code></th>
  <td>32</td>
  <td>This style defines the attributes that all styles receive when the <code>StyleClearAll</code> is used.</td>
</tr><tr>
  <th align="left"><code>wxSCI_STYLE_LINENUMBER</code></th>
  <td>33</td>
  <td>This style sets the attributes of the text used to display line numbers in a line   number margin. The background colour set for this style also sets the background colour   for all margins that do not have any folding mask bits set. That is, any margin for which   <code>mask &amp; wxSCI_MASK_FOLDERS</code> is 0. See <a class="message" href="#SetMarginMask"><code>SetMarginMask</code></a> for more about masks.</td>
</tr><tr>
  <th align="left"><code>wxSCI_STYLE_BRACELIGHT</code></th>
  <td>34</td>
  <td>This style sets the attributes used when highlighting braces with the <a class="message" href="#BraceHighlight"><code>BraceHighlight</code></a> and when highlighting the corresponding indentation with <a class="message" href="#SetHighlightGuide"><code>SetHighlightGuide</code></a>.</td>
</tr><tr>
  <th align="left"><code>wxSCI_STYLE_BRACEBAD</code></th>
  <td>35</td>
  <td>This style sets the display attributes used when marking an unmatched brace with the   <a class="message" href="#BraceBadLight"><code>BraceBadLight</code></a>.</td>
</tr><tr>
  <th align="left"><code>wxSCI_STYLE_CONTROLCHAR</code></th>
  <td>36</td>
  <td>This style sets the font used when drawing control characters. Only the font, size, bold, italics, and character set attributes are used and not the colour attributes. See
  also: <a class="message" href="#SetControlCharSymbol"><code>SetControlCharSymbol</code></a>.</td>
</tr><tr>
  <th align="left"><code>wxSCI_STYLE_INDENTGUIDE</code></th>
  <td>37</td>
  <td>This style sets the foreground and background colours used when drawing the   indentation guides.</td>
</tr><tr>
  <th align="left"><code>STYLE_CALLTIP</code></th>
  <td>38</td>
  <td> Call tips normally use the font attributes defined by <code>wxSCI_STYLE_DEFAULT</code>. Use of <a class="message" href="#CallTipUseStyle"><code>CallTipUseStyle</code></a> causes call tips to use this style instead. Only the font face name, font size, foreground and background colours and character set attributes are used.</td>
</tr><tr>
  <th align="left"><code>wxSCI_STYLE_LASTPREDEFINED</code></th>
  <td>39</td>
  <td>To make it easier for client code to discover the range of styles that are   predefined, this is set to the style number of the last predefined style. This is   currently set to 39 and the last style with an identifier is 37, which reserves space for   future predefined styles.</td>
</tr><tr>
  <th align="left"><code>wxSCI_STYLE_MAX</code></th>
  <td>127</td>
  <td>This is not a style but is the number of the maximum style that can be set. Styles   between <code>wxSCI_STYLE_LASTPREDEFINED</code> and <code>wxSCI_STYLE_MAX</code> would be appropriate   if you used <a class="message" href="#SetStyleBits"><code>SetStyleBits</code></a> to set more than 5 style bits.</td>
</tr>
</tbody></table>
<p>
For each style you can set the font name, size and use of bold, italic and underline, foreground and background colour and the character set. You can also choose to hide text with a given style, display all characters as upper or lower case and fill from the last character on a line to the end of the line (for embedded languages). There is also an experimental attribute to make text read-only.
</p>
<p>
It is entirely up to you how you use styles. If you want to use syntax colouring you might use style 0 for white space, style 1 for numbers, style 2 for keywords, style 3 for strings, style 4 for preprocessor, style 5 for operators, and so on.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#StyleResetDefault">void StyleResetDefault()</a></li>
<li><a class="message" href="#StyleClearAll">void StyleClearAll()</a></li>
<li><a class="message" href="#StyleSetFont">void StyleSetFont (int styleNum, wxFont& font)</a></li>
<li><a class="message" href="#StyleSetSize">void StyleSetSize (int style, int sizePoints)</a></li>
<li><a class="message" href="#StyleSetBold">void StyleSetBold (int style, bool bold)</a></li>
<li><a class="message" href="#StyleSetItalic">void StyleSetItalic (int style, bool italic)</a></li>
<li><a class="message" href="#StyleSetUnderline">void StyleSetUnderline (int style, bool underline)</a></li>
<li><a class="message" href="#StyleSetForeground">void StyleSetForeground (int style, const wxColour& fore)</a></li>
<li><a class="message" href="#StyleSetBackground">void StyleSetBackground (int style, const wxColour& back)</a></li>
<li><a class="message" href="#StyleSetEOLFilled">void StyleSetEOLFilled (int style, bool filled)</a></li>
<li><a class="message" href="#StyleSetCharacterSet">void StyleSetCharacterSet (int style, int characterSet)</a></li>
<li><a class="message" href="#StyleSetCase">void StyleSetCase (int style, int caseMode)</a></li>
<li><a class="message" href="#StyleSetVisible">void StyleSetVisible (int style, bool visible)</a></li>
<li><a class="message" href="#StyleSetChangeable">void StyleSetChangeable (int style, bool changeable)</a></li>
<li><a class="message" href="#StyleSetHotSpot">void StyleSetHotSpot (int style, bool hotspot)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="StyleResetDefault">void StyleResetDefault()</a></h4>
<p>
Resets <code>wxSCI_STYLE_DEFAULT</code> to its state when Scintilla was initialised.
</p>

<div class="divider2"></div>
<h4><a name="StyleClearAll">void StyleClearAll()</a></h4>
<p>
Sets all styles to have the same attributes as <code>wxSCI_STYLE_DEFAULT</code>. If you are setting up Scintilla for syntax colouring, it is likely that the lexical styles you set will be very similar. One way to set the styles is to:<br />
1. Set <code>wxSCI_STYLE_DEFAULT</code> to the common features of all styles.<br />
2. Use <code>StyleClearAll</code> to copy this to all styles.<br />
3. Set the style attributes that make your lexical styles different.
</p>

<div class="divider2"></div>
<h4><a name="StyleSetFont">void StyleSetFont (int styleNum, wxFont& font)</a><br />
    <a name="StyleSetSize">void StyleSetSize (int style, int sizePoints)</a><br />
    <a name="StyleSetBold">void StyleSetBold (int style, bool bold)</a><br />
    <a name="StyleSetItalic">void StyleSetItalic (int style, bool italic)</a></h4>
<p>
These (plus <a class="message" href="#StyleSetCharacterSet"><code>StyleSetCharacterSet</code></a>) set the font attributes that are used to match the fonts you request to those available. The <code>fontName</code> is a zero terminated string holding the name of a font. Under Windows, only the first 32 characters of the name are used and the name is not case sensitive. For internal caching, Scintilla tracks fonts by name and does care about the casing of font names, so please be consistent. On GTK+ 2.x, either GDK or Pango can be used to display text. Pango antialiases text and works well with Unicode but GDK is faster. Prepend a '!' character to the font name to use Pango.
</p>

<div class="divider2"></div>
<h4><a name="StyleSetUnderline">void StyleSetUnderline (int style, bool underline)</a></h4>
<p>
You can set a style to be underlined. The underline is drawn in the foreground colour. All characters with a style that includes the underline attribute are underlined, even if they are white space.
</p>

<div class="divider2"></div>
<h4><a name="StyleSetForeground">void StyleSetForeground (int style, const wxColour& fore)</a><br />
    <a name="StyleSetBackground">void StyleSetBackground (int style, const wxColour& back)</a></h4>
<p>
Text is drawn in the foreground colour. The space in each character cell that is not occupied by the character is drawn in the background colour.
</p>

<div class="divider2"></div>
<h4><a name="StyleSetEOLFilled">void StyleSetEOLFilled (int style, bool filled)</a></h4>
<p>
If the last character in the line has a style with this attribute set, the remainder of the line up to the right edge of the window is filled with the background colour set for the last character. This is useful when a document contains embedded sections in another language such as HTML pages with embedded JavaScript. By setting <code>filled</code> to <code>true</code> and a consistent background colour (different from the background colour set for the HTML styles) to all JavaScript styles then JavaScript sections will be easily distinguished from HTML.
</p>

<div class="divider2"></div>
<h4><a name="StyleSetCharacterSet">void StyleSetCharacterSet (int style, int characterSet)</a></h4>
<p>
You can set a style to use a different character set than the default. The places where such characters sets are likely to be useful are comments and literal strings. For example, <code>StyleSetCharacterSet(SCE_C_STRING, wxwxSCI_CMD_CHARSET_RUSSIAN)</code> would ensure that strings in Russian would display correctly in C and C++ (<code>SCE_C_STRING</code> is the style number used by the C and C++ lexer to display literal strings; it has the value 6). This feature currently only works fully on Windows.
</p>
<p>
The character sets supported on Windows are:<br />
<ul style="list-style-type:none">
<li><code>wxwxSCI_CMD_CHARSET_ANSI</code></li>
<li><code>wxwxSCI_CMD_CHARSET_ARABIC</code></li>
<li><code>wxwxSCI_CMD_CHARSET_BALTIC</code></li>
<li><code>wxwxSCI_CMD_CHARSET_CHINESEBIG5</code></li>
<li><code>wxwxSCI_CMD_CHARSET_DEFAULT</code></li>
<li><code>wxwxSCI_CMD_CHARSET_EASTEUROPE</code></li>
<li><code>wxwxSCI_CMD_CHARSET_GB2312</code></li>
<li><code>wxwxSCI_CMD_CHARSET_GREEK</code></li>
<li><code>wxwxSCI_CMD_CHARSET_HANGUL</code></li>
<li><code>wxwxSCI_CMD_CHARSET_HEBREW</code></li>
<li><code>wxwxSCI_CMD_CHARSET_JOHAB</code></li>
<li><code>wxwxSCI_CMD_CHARSET_MAC</code></li>
<li><code>wxwxSCI_CMD_CHARSET_OEM</code></li>
<li><code>wxwxSCI_CMD_CHARSET_SHIFTJIS</code></li>
<li><code>wxwxSCI_CMD_CHARSET_SYMBOL</code></li>
<li><code>wxwxSCI_CMD_CHARSET_THAI</code></li>
<li><code>wxwxSCI_CMD_CHARSET_TURKISH</code></li>
<li><code>wxwxSCI_CMD_CHARSET_VIETNAMESE</code></li>
</ul>
</p>
<p>
The character sets supported on GTK+ are:<br />
</p>
<ul style="list-style-type:none">
<li><code>wxwxSCI_CMD_CHARSET_ANSI</code></li>
<li><code>wxwxSCI_CMD_CHARSET_EASTEUROPE</code></li>
<li><code>wxwxSCI_CMD_CHARSET_GB2312</code></li>
<li><code>wxwxSCI_CMD_CHARSET_HANGUL</code></li>
<li><code>wxwxSCI_CMD_CHARSET_SHIFTJIS</code></li>
</ul>

<div class="divider2"></div>
<h4><a name="StyleSetCase">void StyleSetCase (int style, int caseMode)</a></h4>
<p>
The value of caseMode determines how text is displayed. You can set upper case (<code>wxSCI_CASE_UPPER</code>, 1) or lower case (<code>wxSCI_CASE_LOWER</code>, 2) or display normally (<code>wxSCI_CASE_MIXED</code>, 0). This does not change the stored text, only how it is displayed.
</p>

<div class="divider2"></div>
<h4><a name="StyleSetVisible">void StyleSetVisible (int style, bool visible)</a></h4>
<p>
Text is normally visible. However, you can completely hide it by giving it a style with the <code>visible</code> set to false. This could be used to hide embedded formatting instructions or hypertext keywords in HTML or XML.
</p>

<div class="divider2"></div>
<h4><a name="StyleSetChangeable">void StyleSetChangeable (int style, bool changeable)</a></h4>
<p>
This is an experimental and incompletely implemented style attribute. The default setting is <code>changeable</code> set <code>true</code> but when set <code>false</code> it makes text read-only. Currently it only stops the caret from being within not-changeable text and does not yet stop deleting a range that contains not-changeable text.
</p>

<div class="divider2"></div>
<h4><a name="StyleSetHotSpot">void StyleSetHotSpot (int style, bool hotspot)</a></h4>
<p>
This style is used to mark ranges of text that can detect mouse clicks. The cursor changes to a hand over hotspots, and the foreground, and background colours may change and an underline appear to indicate that these areas are sensitive to clicking. This may be used to allow hyperlinks to other documents.
</p>
<p>
See also: <code><a class="message" href="#SetHotspotActiveForeground">SetHotspotActiveForeground</a>, <a class="message" href="#SetHotspotActiveBackground">SetHotspotActiveBackground</a></code>
</p>

<div class="divider1"></div>
<h3 id="CaretAndSelectionStyles">Caret, selection, and hotspot styles</h3>

<p>
The selection is shown by changing the foreground and/or background colours. If one of these is not set then that attribute is not changed for the selection. The default is to show the selection by changing the background to light gray and leaving the foreground the same as when it was not selected. When there is no selection, the current insertion point is marked by the text caret. This is a vertical line that is normally blinking on and off to attract the users attention.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#SetSelForeground">void SetSelForeground (bool useSetting, const wxColour& fore)</a></li>
<li><a class="message" href="#SetSelBackground">void SetSelBackground (bool useSetting, const wxColour& back)</a></li>
<li><a class="message" href="#SetSelAlpha">void SetSelAlpha (int alpha)</a></li>
<li><a class="message" href="#GetSelAlpha">int GetSelAlpha()</a></li>
<li><a class="message" href="#SetCaretForeground">void SetCaretForeground (const wxColour& fore)</a></li>
<li><a class="message" href="#GetCaretForeground">wxColour GetCaretForeground()</a></li>
<li><a class="message" href="#SetCaretLineVisible">void SetCaretLineVisible (bool show)</a></li>
<li><a class="message" href="#GetCaretLineVisible">bool GetCaretLineVisible()</a></li>
<li><a class="message" href="#SetCaretLineBackground">void SetCaretLineBackground (const wxColour& back)</a></li>
<li><a class="message" href="#GetCaretLineBackground">wxColour GetCaretLineBackground()</a></li>
<li><a class="message" href="#SetCaretLineBackgroundAlpha">void SetCaretLineBackgroundAlpha (int alpha)</a></li>
<li><a class="message" href="#GetCaretLineBackgroundAlpha">int GetCaretLineBackgroundAlpha()</a></li>
<li><a class="message" href="#SetCaretPeriod">void SetCaretPeriod (int milliseconds)</a></li>
<li><a class="message" href="#GetCaretPeriod">int GetCaretPeriod()</a></li>
<li><a class="message" href="#SetCaretWidth">void SetCaretWidth (int pixels)</a></li>
<li><a class="message" href="#GetCaretWidth">int GetCaretWidth()</a></li>
<li><a class="message" href="#SetHotspotActiveForeground">void SetHotspotActiveForeground (bool useSetting, const wxColour& fore)</a></li>
<li><a class="message" href="#SetHotspotActiveBackground">void SetHotspotActiveBackground (bool useSetting, const wxColour& back)</a></li>
<li><a class="message" href="#SetHotspotActiveUnderline">void SetHotspotActiveUnderline (bool underline)</a></li>
<li><a class="message" href="#SetHotspotSingleLine">void SetHotspotSingleLine (bool singleLine)</a></li>
<li><a class="message" href="#SetControlCharSymbol">void SetControlCharSymbol (int symbol)</a></li>
<li><a class="message" href="#GetControlCharSymbol">int GetControlCharSymbol()</a></li>
<li><a class="message" href="#SetCaretSticky">void SetCaretSticky (bool useCaretStickyBehaviour)</a></li>
<li><a class="message" href="#GetCaretSticky">bool GetCaretSticky ()</a></li>
<li><a class="message" href="#ToggleCaretSticky">void ToggleCaretSticky ()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetSelForeground">void SetSelForeground (bool useSetting, const wxColour& fore)</a><br/>
    <a name="SetSelBackground">void SetSelBackground (bool useSetting, const wxColour& back)</a></h4>
<p>
You can choose to override the default selection colouring with these two functions. The colour you provide is used if you set <code>useSetting</code> to <code>true</code>. If it is set to <code>false</code>, the default colour colouring is used and the <code>colour</code> argument has no effect.
</p>

<div class="divider2"></div>
<h4><a name="SetSelAlpha">void SetSelAlpha (int alpha)</a><br />
    <a name="GetSelAlpha">GetSelAlpha()</a></h4>
<p>
The selection background can be drawn translucently in the selection background colour by setting an alpha value.
</p>

<div class="divider2"></div>
<h4><a name="SetCaretForeground">void SetCaretForeground (const wxColour& fore)</a><br />
    <a name="GetCaretForeground">wxColour GetCaretForeground()</a></h4>
<p>
The colour of the caret can be set with <code>SetCaretForeground</code> and retrieved with <code>GetCaretForeground</code>.
</p>

<div class="divider2"></div>
<h4><a name="SetCaretLineVisible">void SetCaretLineVisible (bool show)</a><br />
    <a name="GetCaretLineVisible">bool GetCaretLineVisible()</a><br />
    <a name="SetCaretLineBackground">void SetCaretLineBackground (const wxColour& back)</a><br />
    <a name="GetCaretLineBackground">wxColour GetCaretLineBackground()</a></h4>
    <a name="SetCaretLineBackgroundAlpha">void SetCaretLineBackground (int alpha)</a><br />
    <a name="GetCaretLineBackgroundAlpha">int GetCaretLineBackgroundAlpha()</a></h4>
<p>
You can choose to make the background colour of the line containing the caret different. To do this, set the desired background colour with <code>SetCaretLineBackground</code>, then use <code>SetCaretLineVisible (true)</code> to enable the effect. You can cancel the effect with <code>SetCaretLineVisible (false)</code>. The two <code>GetCaret...</code> functions return the state and the colour. This form of background colouring has highest priority when a line has markers that would otherwise change the background colour. The caret line may also be drawn translucently which allows other background colours to show through. This is done by setting the alpha (translucency) value by calling <code>SetCaretLineBackgroundAlpha</code>. When the alpha is not <code>wxSCI_ALPHA_NOALPHA</code>, the caret line is drawn after all other features so will affect the colour of all other features.
</p>

<div class="divider2"></div>
<h4><a name="SetCaretPeriod">void SetCaretPeriod (int milliseconds)</a><br />
    <a name="GetCaretPeriod">int GetCaretPeriod()</a></h4>
<p>
The rate at which the caret blinks can be set with <code>SetCaretPeriod</code> which determines the time in milliseconds that the caret is visible or invisible before changing state. Setting the period to 0 stops the caret blinking. The default value is 500  milliseconds. <code>GetCaretPeriod</code> returns the current setting.
</p>

<div class="divider2"></div>
<h4><a name="SetCaretWidth">void SetCaretWidth (int pixels)</a><br/>
    <a name="GetCaretWidth">int GetCaretWidth()</a></h4>
<p>
The width of the caret can be set with <code>SetCaretWidth</code> to a value of 0, 1, 2 or 3 pixels. The default width is 1 pixel. You can read back the current width with <code>GetCaretWidth</code>. A width of 0 makes the caret invisible.
</p>

<div class="divider2"></div>
<h4><a name="SetHotspotActiveForeground">void SetHotspotActiveForeground (bool useSetting, const wxColour& fore)</a><br />
    <a name="SetHotspotActiveBackground">void SetHotspotActiveBackground (bool useSetting, const wxColour& back)</a><br />
    <a name="SetHotspotActiveUnderline">void SetHotspotActiveUnderline (bool underline)</a><br />
    <a name="SetHotspotSingleLine">void SetHotspotSingleLine (bool singleLine)</a></h4>
<p>
While the cursor hovers over text in a style with the hotspot attribute set, the default colouring can be modified and an underline drawn with these settings. Single line mode stops a hotspot from wrapping onto next line.
</p>
<p>
See also: <code><a class="message" href="#StyleSetHotSpot">StyleSetHotSpot</a></code>
</p>

<div class="divider2"></div>
<h4><a name="SetControlCharSymbol">void SetControlCharSymbol (int symbol)</a><br />
    <a name="GetControlCharSymbol">int GetControlCharSymbol()</a></h4>
<p>
By default, Scintilla displays control characters (characters with codes less than 32) in a rounded rectangle as ASCII mnemonics:<br />"<code>NUL</code>", "<code>SOH</code>", "<code>STX</code>", "<code>ETX</code>", "<code>EOT</code>", "<code>ENQ</code>", "<code>ACK</code>", "<code>BEL</code>", "<code>BS</code>", "<code>HT</code>", "<code>LF</code>", "<code>VT</code>", "<code>FF</code>", "<code>CR</code>", "<code>SO</code>", "<code>SI</code>", "<code>DLE</code>", "<code>DC1</code>", "<code>DC2</code>", "<code>DC3</code>", "<code>DC4</code>", "<code>NAK</code>", "<code>SYN</code>", "<code>ETB</code>", "<code>CAN</code>", "<code>EM</code>", "<code>SUB</code>", "<code>ESC</code>", "<code>FS</code>", "<code>GS</code>", "<code>RS</code>", "<code>US</code>". These mnemonics come from the early days of signaling, though some are still used (<code>LF</code> = Line Feed, <code>BS</code> = Back Space, <code>CR</code> = Carriage Return, for example).
</p>
<p>
You can choose to replace these mnemonics by a nominated symbol with an ASCII code in the range 32 to 255. If you set a symbol value less than 32, all control characters are displayed as mnemonics. The symbol you set is rendered in the font of the style set for the character. You can read back the current symbol with the <code>GetControlCharSymbol</code>. The default symbol value is 0.
</p>

<div class="divider2"></div>
<h4><a name="SetCaretSticky">void SetCaretSticky (bool useCaretStickyBehaviour)</a><br />
    <a name="GetCaretSticky">bool GetCaretSticky ()</a><br />
    <a name="ToggleCaretSticky">void ToggleCaretSticky ()</a></h4>
<p>
These messages set, get or toggle the caretSticky flag which controls when the last position of the caret on the line is saved. When set to true, the position is not saved when you type a character, a tab, paste the clipboard content or press backspace.
</p>

<div class="divider1"></div>
<h3 id="Margins">Margins</h3>

<p>
There may be up to three margins to the left of the text display, plus a gap either side of the text. Each margin can be set to display either symbols or line numbers with <a class="message" href="#SetMarginType"><code>SetMarginType</code></a>. The markers that can be displayed in each margin are set with <a class="message" href="#SetMarginMask"><code>SetMarginMask</code></a>. Any markers not associated with a visible margin will be displayed as changes in background colour in the text. A width in pixels can be set for each margin. Margins with a zero width are ignored completely. You can choose if a mouse click in a margin sends a <a class="message" href="#wxEVT_SCI_MARGINCLICK"><code>wxEVT_SCI_MARGINCLICK</code></a> notification to the container or selects a line of text.
</p>
<p>
The margins are numbered 0 to 2. Using a margin number outside the valid range has no effect. By default, margin 0 is set to display line numbers, but is given a width of 0, so it is hidden. Margin 1 is set to display non-folding symbols and is given a width of 16 pixels, so it is visible. Margin 2 is set to display the folding symbols, but is given a width of 0, so it is hidden. Of course, you can set the margins to be whatever you wish.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#SetMarginType">void SetMarginType (int margin, int marginType)</a></li>
<li><a class="message" href="#GetMarginType">int GetMarginType (int margin)</a></li>
<li><a class="message" href="#SetMarginWidth">void SetMarginWidth (int margin, int pixels)</a></li>
<li><a class="message" href="#GetMarginWidth">int GetMarginWidth (int margin)</a></li>
<li><a class="message" href="#SetMarginMask">void SetMarginMask (int margin, int mask)</a></li>
<li><a class="message" href="#GetMarginMask">int GetMarginMask (int margin)</a></li>
<li><a class="message" href="#SetMarginSensitive">void SetMarginSensitive (int margin, bool sensitive)</a></li>
<li><a class="message" href="#GetMarginSensitive">bool GetMarginSensitive (int margin)</a></li>
<li><a class="message" href="#SetMarginLeft">void SetMarginLeft (int pixels)</a></li>
<li><a class="message" href="#GetMarginLeft">int GetMarginLeft()</a></li>
<li><a class="message" href="#SetMarginRight">void SetMarginRight (int pixels)</a></li>
<li><a class="message" href="#GetMarginRight">int GetMarginRight()</a></li>
<li><a class="message" href="#SetFoldMarginColour">void SetFoldMarginColour (bool useSetting, const wxColour& back)</a></li>
<li><a class="message" href="#SetFoldMarginHiColour">void SetFoldMarginHiColour (bool useSetting, const wxColour& fore)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetMarginType">void SetMarginType (int margin, int marginType)</a><br />
    <a name="GetMarginType">int GetMarginType (int margin)</a></h4>
<p>
These two routines set and get the type of a margin. The margin argument should be 0, 1 or 2. You can use the predefined constants <code>wxSCI_MARGIN_SYMBOL</code> (0) and <code>wxSCI_MARGIN_NUMBER</code> (1) to set a margin as either a line number or a symbol margin. By convention, margin 0 is used for line numbers and the other two are used for symbols.
</p>

<div class="divider2"></div>
<h4><a name="SetMarginWidth">void SetMarginWidth (int margin, int pixels)</a><br />
    <a name="GetMarginWidth">int GetMarginWidth (int margin)</a></h4>
<p>
These routines set and get the width of a margin in pixels. A margin with zero width is invisible. By default, Scintilla sets margin 1 for symbols with a width of 16 pixels, so this is a reasonable guess if you are not sure what would be appropriate. Line number margins widths should take into account the number of lines in the document and the line number style. You could use something like <a class="message" href="#TextWidth"><code>TextWidth (wxSCI_STYLE_LINENUMBER, "_99999")</code></a> to get a suitable width.
</p>

<div class="divider2"></div>
<h4><a name="SetMarginMask">void SetMarginMask (int margin, int mask)</a><br />
    <a name="GetMarginMask">int GetMarginMask (int margin)</a></h4>
<p>
The mask is a 32-bit value. Each bit corresponds to one of 32 logical symbols that can be displayed in a margin that is enabled for symbols. There is a useful constant, <code>wxSCI_MASK_FOLDERS</code> (0xFE000000), that is a mask for the 7 logical symbols used to denote folding. You can assign a wide range of symbols and colours to each of the 32 logical symbols, see <a href="#Markers">Markers</a> for more information. If <code>(mask &amp; wxSCI_MASK_FOLDERS)==0</code>, the margin background colour is controlled by style 33 (<a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_LINENUMBER</code></a>).
</p>
<p>
You add logical markers to a line with <a class="message" href="#MarkerAdd"><code>MarkerAdd</code></a>. If a line has an associated marker that does not appear in the mask of any margin with a non-zero width, the marker changes the background colour of the line. For example, suppose you decide to use logical marker 10 to mark lines with a syntax error and you want to show such lines by changing the background colour. The mask for this marker is 1 shifted left 10 times (1&lt;&lt;10) which is 0x400. If you make sure that no symbol margin includes 0x400 in its mask, any line with the marker gets the background colour changed.
</p>
<p>
To set a non-folding margin 1 use <code>SetMarginMask (1, ~wxSCI_MASK_FOLDERS)</code>; to set a folding margin 2 use <code>SetMarginMask(2, wxSCI_MASK_FOLDERS)</code>. This is the default set by Scintilla. <code>~wxSCI_MASK_FOLDERS</code> is 0x1FFFFFF in hexadecimal. Of course, you may need to display all 32 symbols in a margin, in which case use <code>SetMarginMask (margin, -1)</code>.
</p>

<div class="divider2"></div>
<h4><a name="SetMarginSensitive">void SetMarginSensitive (int margin, bool sensitive)</a><br />
    <a name="GetMarginSensitive">bool GetMarginSensitive (int margin)</a></h4>
<p>
Each of the three margins can be set sensitive or insensitive to mouse clicks. A click in a sensitive margin sends a <a class="message" href="#wxEVT_SCI_MARGINCLICK"><code>wxEVT_SCI_MARGINCLICK </code></a> <a class="jump" href="#Notifications">notification</a> to the container. Margins that are not sensitive act as selection margins which make it easy to select ranges of lines. By default, all margins are insensitive.
</p>

<div class="divider2"></div>
<h4><a name="SetMarginLeft">void SetMarginLeft (int pixels)</a><br />
    <a name="GetMarginLeft">int GetMarginLeft()</a><br />
    <a name="SetMarginRight">void SetMarginRight (int pixels)</a><br />
    <a name="GetMarginRight">int GetMarginRight()</a></h4>
<p>
Set and get the width of the blank margin on both sides of the text in pixels. The default is to one pixel on each side.
</p>

<div class="divider2"></div>
<h4><a name="SetFoldMarginColour">void SetFoldMarginColour (bool useSetting, const wxColour& back)</a><br />
    <a name="SetFoldMarginHiColour">void SetFoldMarginHiColour (bool useSetting, const wxColour& fore)</a></h4>
<p>
Allow changing the colour of the fold margin and fold margin highlight. On Windows the fold margin colour defaults to ::GetSysColor(COLOR_3DFACE) and the fold margin highlight colour to ::GetSysColor(COLOR_3DHIGHLIGHT).
</p>

<div class="divider1"></div>
<h3 id="OtherSettings">Other settings</h3>

<ul style="list-style-type:none">
<li><a class="message" href="#SetUsePalette">SetUsePalette: Currently not implemented!</a></li>
<li><a class="message" href="#GetUsePalette">GetUsePalette: Currently not implemented!</a></li>
<li><a class="message" href="#SetBufferedDraw">void SetBufferedDraw (bool buffered)</a></li>
<li><a class="message" href="#GetBufferedDraw">bool GetBufferedDraw()</a></li>
<li><a class="message" href="#SetTwoPhaseDraw">void SetTwoPhaseDraw (bool twoPhase)</a></li>
<li><a class="message" href="#GetTwoPhaseDraw">bool GetTwoPhaseDraw()</a></li>
<li><a class="message" href="#SetCodePage">void SetCodePage (int codePage)</a></li>
<li><a class="message" href="#GetCodePage">int GetCodePage()</a></li>
<li><a class="message" href="#SetWordChars">void SetWordChars (const wxString& characters)</a></li>
<li><a class="message" href="#SetWhitespaceChars">void SetWhitespaceChars (const wxString& characters)</a></li>
<li><a class="message" href="#SetCharsDefault">void SetCharsDefault()</a></li>
<li><a class="message" href="#GrabSCIFocus">GrabSCIFocus: Currently not implemented!</a></li>
<li><a class="message" href="#SetSCIFocus">void SetSCIFocus (bool focus)</a></li>
<li><a class="message" href="#GetSCIFocus">bool GetSCIFocus()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetBufferedDraw">void SetBufferedDraw (bool buffered)</a><br />
    <a name="GetBufferedDraw">bool GetBufferedDraw()</a></h4>
<p>
Turn buffered drawing on or off and report the buffered drawing state. Buffered drawing draws each line into a bitmap rather than directly to the screen and then copies the bitmap to the screen. This avoids flickering although it does take longer. The default is for drawing to be buffered.
</p>

<div class="divider2"></div>
<h4><a name="SetTwoPhaseDraw">void SetTwoPhaseDraw (bool twoPhase)</a><br />
    <a name="GetTwoPhaseDraw">bool GetTwoPhaseDraw()</a></h4>
<p>
Two phase drawing is a better but slower way of drawing text. In single phase drawing each run of characters in one style is drawn along with its background. If a character overhangs the end of a run, such as in "<i>V</i>_" where the "<i>V</i>" is in a different style from the "_", then this can cause the right hand side of the "<i>V</i>" to be overdrawn by the background of the "_" which cuts it off. Two phase drawing fixes this by drawing all the backgrounds first and then drawing the text in transparent mode. Two phase drawing may flicker more than single phase unless buffered drawing is on. The default is for drawing to be two phase.
</p>

<div class="divider2"></div>
<h4><a name="SetCodePage">void SetCodePage (int codePage)</a><br />
    <a name="GetCodePage">int GetCodePage()</a></h4>
<p>
Scintilla has some support for Japanese, Chinese and Korean DBCS. Use this with <code>codePage</code> set to the code page number to set Scintilla to use code page information to ensure double byte characters are treated as one character rather than two. This also stops the caret from moving between the two bytes in a double byte character. Call with <code>codePage</code> set to zero to disable DBCS support. The default is <code>SetCodePage (0)</code>.
</p>
<p>
Code page <code>wxSCI_CP_UTF8</code> (65001) sets Scintilla into Unicode mode with the document treated as a sequence of characters expressed in UTF-8. The text is converted to the platform's normal Unicode encoding before being drawn by the OS and thus can display Hebrew, Arabic, Cyrillic, and Han characters. Languages which can use two characters stacked vertically in one horizontal space, such as Thai, will mostly work but there are some issues where the characters are drawn separately leading to visual glitches. Bi-directional text is not supported.
</p>
<p>
On Windows, code page can be set to 932 (Japanese Shift-JIS), 936 (Simplified Chinese GBK), 949 (Korean), and 950 (Traditional Chinese Big5) although these may require installation of language specific support.
</p>
<p>
On GTK+, code page <code>wxSCI_CP_DBCS</code> (1) sets Scintilla into multi byte character mode as is required for Japanese language processing with the EUC encoding.
</p>
<p>
For GTK+, the locale should be set to a Unicode locale with a call similar to <code>setlocale (LC_CTYPE, "en_US.UTF-8")</code>. Fonts with an <code>"iso10646"</code> registry should be used in a font set. Font sets are a comma separated list of partial font specifications where each partial font specification can be in the form:<br />
<code>foundry-fontface-charsetregistry-encoding</code> or<br />
<code>fontface-charsetregistry-encoding</code> or <br />
<code>foundry-fontface</code> or<br />
<code>fontface</code>.<br />
An example is <code>"misc-fixed-iso10646-1,*"</code>.
</p>
<p>
Setting <code>codePage</code> to a non-zero value that is not <code>wxSCI_CP_UTF8</code> is operating system dependent.
</p>

<div class="divider2"></div>
<h4><a name="SetWordChars">void SetWordChars (const wxString& characters)</a></h4>
<p>
Scintilla has several functions that operate on words, which are defined to be contiguous sequences of characters from a particular set of characters. Defines which characters are members of that set. The character sets are set to default values before processing this function. For example, if you don't allow '_' in your set of characters use:<br />
<code>SetWordChars (0, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")</code>;
</p>

<div class="divider2"></div>
<h4><a name="SetWhitespaceChars">void SetWhitespaceChars (const wxString& characters)</a></h4>
<p>
Similar to <code>SetWordChars</code>, allows the user to define which chars Scintilla considers as whitespace.  Setting the whitespace chars allows the user to fine-tune Scintilla's behavior doing such things as moving the cursor to the start or end of a word; for example, by defining punctuation chars as whitespace, they will be skipped over when the user presses ctrl+left or ctrl+right. This function should be called after <code>SetWordChars</code> as it will reset the whitespace characters to the default set.
</p>

<div class="divider2"></div>
<h4><a name="SetCharsDefault">void SetCharsDefault()</a></h4>
<p>
Use the default sets of word and whitespace characters. This sets whitespace to space, TAB and other characters with codes less than 0x20, with word characters set to alphanumeric and '_'.
</p>

<div class="divider2"></div>
<h4><a name="SetSCIFocus">void SetSCIFocus()</a></h4>
<p>
The internal focus flag can be set with <code>SetSCIFocus</code>. This is used by clients that have complex focus requirements such as having their own window that gets the real focus but with the need to indicate that Scintilla has the logical focus.
</p>

<div class="divider1"></div>
<h3 id="BraceHighlighting">Brace highlighting</h3>

<ul style="list-style-type:none">
<li><a class="message" href="#BraceHighlight">void BraceHighlight (int pos1, int pos2)</a></li>
<li><a class="message" href="#BraceBadLight">void BraceBadLight (int pos)</a></li>
<li><a class="message" href="#BraceMatch">int BraceMatch (int pos)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="BraceHighlight">void BraceHighlight (int pos1, int pos2)</a></h4>
<p>
Up to two characters can be highlighted in a 'brace highlighting style', which is defined as style number <a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_BRACELIGHT</code></a> (34). Use pos1 = pos2 = wxSTC_INVALID_POSITION to remove the highlighting. If you have enabled indent guides, you may also wish to highlight the indent that corresponds with the brace. You can locate the column with <a class="message" href="#GetColumn"><code>GetColumn</code></a> and highlight the indent with <a class="message" href="#SetHighlightGuide"><code>SetHighlightGuide</code></a>.
</p>

<div class="divider2"></div>
<h4><a name="BraceBadLight">void BraceBadLight (int pos)</a></h4>
<p>
If there is no matching brace then the <a class="jump" href="#StyleDefinition">brace badlighting style</a>, style <code>wxSCI_STYLE_BRACEBAD</code> (35), can be used to show the brace that is unmatched. Using a position of <code>wxSCI_INVALID_POSITION</code> removes the highlight.
</p>

<div class="divider2"></div>
<h4><a name="BraceMatch">int BraceMatch (int pos)</a></h4>
<p>
<code>BraceMatch</code> finds a corresponding matching brace given <code>pos</code>, the position of one brace. The brace characters handled are '(', ')', '[', ']', '{', '}', '&lt;', and '&gt;'. The search is forwards from an opening brace and backwards from a closing brace. If the character at position is not a brace character, or a matching brace cannot be found, the return value is <code>wxSCI_INVALID_POSITION</code>. Otherwise, the return value is the position of the matching brace.
</p>
<p>
A match only occurs if the style of the matching brace is the same as the starting brace or the matching brace is beyond the end of styling. Nested braces are handled correctly.
</p>
<p>
It's important to realize that this method does <b>NOT</b> do any highlighting, it just finds the matching brace.
</p>

<div class="divider1"></div>
<h3 id="TabsAndIndentationGuides">Tabs and Indentation Guides</h3>

<p>
Indentation (the white space at the start of a line) is often used by programmers to clarify program structure and in some languages, for example Python, it may be part of the language syntax. Tabs are normally used in editors to insert a TAB character or to pad text with spaces up to the next TAB.
</p>
<p>
Scintilla can be set to treat TAB and backspace in the white space at the start of a line in a special way: inserting a TAB indents the line to the next indent position rather than just inserting a TAB at the current character position and backspace unindents the line rather than deleting a character. Scintilla can also display indentation guides (vertical lines) to help you to generate code.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#SetTabWidth">void SetTabWidth (int tabWidth)</a></li>
<li><a class="message" href="#GetTabWidth">int GetTabWidth()</a></li>
<li><a class="message" href="#SetUseTabs">void SetUseTabs (bool useTabs)</a></li>
<li><a class="message" href="#GetUseTabs">bool GetUseTabs()</a></li>
<li><a class="message" href="#SetIndent">void SetIndent (int indentSize)</a></li>
<li><a class="message" href="#GetIndent">int GetIndent()</a></li>
<li><a class="message" href="#SetTabIndents">void SetTabIndents (bool tabIndents)</a></li>
<li><a class="message" href="#GetTabIndents">bool GetTabIndents()</a></li>
<li><a class="message" href="#SetBackSpaceUnIndents">void SetBackSpaceUnIndents (bool bsUnIndents)</a></li>
<li><a class="message" href="#GetBackSpaceUnIndents">bool GetBackSpaceUnIndents()</a></li>
<li><a class="message" href="#SetLineIndentation">void SetLineIndentation (int line, int indentSize)</a></li>
<li><a class="message" href="#GetLineIndentation">int GetLineIndentation (int line)</a></li>
<li><a class="message" href="#GetLineIndentPosition">int GetLineIndentPosition (int line)</a></li>
<li><a class="message" href="#SetIndentationGuides">void SetIndentationGuides (bool show)</a></li>
<li><a class="message" href="#GetIndentationGuides">bool GetIndentationGuides()</a></li>
<li><a class="message" href="#SetHighlightGuide">void SetHighlightGuide (int column)</a></li>
<li><a class="message" href="#GetHighlightGuide">int GetHighlightGuide()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetTabWidth">void SetTabWidth (int tabWidth)</a><br />
    <a name="GetTabWidth">int GetTabWidth()</a></h4>
<p>
<code>SetTabWidth</code> sets the size of a TAB as a multiple of the size of a space character in <code>wxSCI_STYLE_DEFAULT</code>. The default TAB width is 8 characters. There are no limits on TAB sizes, but values less than 1 or large values may have undesirable effects.
</p>

<div class="divider2"></div>
<h4><a name="SetUseTabs">void SetUseTabs (bool useTabs)</a><br />
    <a name="GetUseTabs">bool GetUseTabs()</a></h4>
<p>
<code>SetUseTabs</code> determines whether indentation should be created out of a mixture of tabs and spaces or be based purely on spaces. Set <code>useTabs</code> to <code>false</code> to create all tabs and indents out of spaces. The default is <code>true</code>. You can use <a class="message" href="#GetColumn"><code>GetColumn</code></a> to get the column of a position taking the width of a TAB into account.
</p>

<div class="divider2"></div>
<h4><a name="SetIndent">void SetIndent (int indentSize)</a><br />
    <a name="GetIndent">int GetIndent()</a></h4>
<p>
<code>SetIndent</code> sets the size of indentation in terms of the width of a space in <a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_DEFAULT</code></a>. If you set a width of 0, the indent size is the same as the TAB size. There are no limits on indent sizes, but values less than 0 or large values may have undesirable effects.
</p>

<div class="divider2"></div>
<h4><a name="SetTabIndents">void SetTabIndents (bool tabIndents)</a><br />
    <a name="GetTabIndents">bool GetTabIndents()</a><br />
    <a name="SetBackSpaceUnIndents">void SetBackSpaceUnIndents (bool bsUnIndents)</a><br />
    <a name="GetBackSpaceUnIndents">bool GetBackSpaceUnIndents()</a></h4>
<p>
Inside indentation white space, the TAB and backspace keys can be made to indent and unindent rather than insert a TAB character or delete a character with the <code>SetTabIndents</code> and <code>SetBackSpaceUnIndents</code> functions.
</p>

<div class="divider2"></div>
<h4><a name="SetLineIndentation">void SetLineIndentation (int line, int indentSize)</a><br />
    <a name="GetLineIndentation">int GetLineIndentation (int line)</a></h4>
<p>
The amount of indentation on a line can be discovered and set with <code>GetLineIndentation</code> and <code>SetLineIndentation</code>. The indentation is measured in character columns, which correspond to the width of space characters.
</p>

<div class="divider2"></div>
<h4><a name="GetLineIndentPosition">int GetLineIndentPosition (int line)</a></h4>
<p>
This returns the position at the end of indentation of a line.
</p>

<div class="divider2"></div>
<h4><a name="SetIndentationGuides">void SetIndentationGuides (bool show)</a><br />
    <a name="GetIndentationGuides">bool GetIndentationGuides()</a></h4>
<p>
Indentation guides are dotted vertical lines that appear within indentation white space every indent size columns. They make it easy to see which constructs line up especially when they extend over multiple pages. Style <a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_INDENTGUIDE</code></a> (37) is used to specify the foreground and background colour of the indentation guides.
</p>

<div class="divider2"></div>
<h4><a name="SetHighlightGuide">void SetHighlightGuide (int column)</a><br />
    <a name="GetHighlightGuide">int GetHighlightGuide()</a></h4>
<p>
When brace highlighting occurs, the indentation guide corresponding to the braces may be highlighted with the brace highlighting style, <a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_BRACELIGHT</code></a> (34). Set <code>column</code> to 0 to cancel this highlight.
</p>

<div class="divider1"></div>
<h3 id="Markers">Markers</h3>

<p>
There are 32 markers, numbered 0 to 31, and you can assign any combination of them to each line in the document. Markers appear in the <a class="jump" href="#Margins">selection margin</a> to the left of the text. If the selection margin is set to zero width, the background colour of the whole line is changed instead. Marker numbers 25 to 31 are used by Scintilla in folding margins, and have symbolic names of the form <code>wxSCI_MARKNUM_...</code>*, for example <code>wxSCI_MARKNUM_FOLDEROPEN</code>.
</p>
<p>
Marker numbers 0 to 24 have no pre-defined function; you can use them to mark syntax errors or the current point of execution, break points, or whatever you need marking. If you do not need folding, you can use all 32 for any purpose you wish.
</p>
<p>
Each marker number has a symbol associated with it. You can also set the foreground and background colour for each marker number, so you can use the same symbol more than once with different colouring for different uses. Scintilla has a set of symbols you can assign (<code>wxSCI_MARK_</code>*) or you can use characters. By default, all 32 markers are set to <code>wxSCI_MARK_CIRCLE</code> with a black foreground and a white background.
</p>
<p>
The markers are drawn in the order of their numbers, so higher numbered markers appear on top of lower numbered ones. Markers try to move with their text by tracking where the start of their line moves. When a line is deleted, its markers are combined, by an <code>OR</code> operation, with the markers of the previous line.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#MarkerDefine">void MarkerDefine (int markerNumber, int markerSymbol)</a></li>
<li><a class="message" href="#MarkerDefineBitmap">void MarkerDefineBitmap (int markerNumber, const wxBitmap& bmp)</a></li>
<li><a class="message" href="#MarkerSetForeground">void MarkerSetForeground (int markerNumber, const wxColour& fore)</a></li>
<li><a class="message" href="#MarkerSetBackground">void MarkerSetBackground (int markerNumber, const wxColour& back)</a></li>
<li><a class="message" href="#MarkerSetAlpha">void MarkerSetAlpha (int markerNumber, int alpha)</a></li>
<li><a class="message" href="#MarkerAdd">int MarkerAdd (int line, int markerNumber)</a></li>
<li><a class="message" href="#MarkerAddSet">int MarkerAddSet (int line, int markerSet)</a></li>
<li><a class="message" href="#MarkerDelete">void MarkerDelete (int line, int markerNumber)</a></li>
<li><a class="message" href="#MarkerDeleteAll">void MarkerDeleteAll (int markerNumber)</a></li>
<li><a class="message" href="#MarkerGet">int MarkerGet (int line)</a></li>
<li><a class="message" href="#MarkerNext">int MarkerNext (int lineStart, int markerMask)</a></li>
<li><a class="message" href="#MarkerPrevious">nt MarkerPrevious (int lineStart, int markerMask)</a></li>
<li><a class="message" href="#MarkerLineFromHandle">int MarkerLineFromHandle (int handle)</a></li>
<li><a class="message" href="#MarkerDeleteHandle">void MarkerDeleteHandle (int handle)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="MarkerDefine">void MarkerDefine (int markerNumber, int markerSymbol)</a></h4>
<p>
Associates a marker number in the range 0 to 31 with one of the marker symbols or an ASCII character. The general-purpose marker symbols currently available are:
</p>
<ul style="list-style-type:none">
<li><code>wxSCI_MARK_CIRCLE</code></li>
<li><code>wxSCI_MARK_ROUNDRECT</code></li>
<li><code>wxSCI_MARK_ARROW</code></li>
<li><code>wxSCI_MARK_SMALLRECT</code></li>
<li><code>wxSCI_MARK_SHORTARROW</code></li>
<li><code>wxSCI_MARK_EMPTY</code></li>
<li><code>wxSCI_MARK_ARROWDOWN</code></li>
<li><code>wxSCI_MARK_MINUS</code></li>
<li><code>wxSCI_MARK_PLUS</code></li>
<li><code>wxSCI_MARK_ARROWS</code></li>
<li><code>wxSCI_MARK_DOTDOTDOT</code></li>
<li><code>wxSCI_MARK_EMPTY</code></li>
<li><code>wxSCI_MARK_BACKGROUND</code></li>
<li><code>wxSCI_MARK_FULLRECT</code></li>
</ul>

<div class="divider2"></div>
<h4><a name="MarkerDefineBitmap">void MarkerDefineBitmap (int markerNumber, const wxBitmap& bmp)</a></h4>
<p>
Markers can be set to pixmaps. Pixmaps use the <code>wxSCI_MARK_PIXMAP</code> marker symbol.
</p>
<p>
The <code>wxSCI_MARK_BACKGROUND</code> marker changes the background colour of the line only. The <code>wxSCI_MARK_FULLRECT</code> symbol mirrors this, changing only the margin background colour. The <code>wxSCI_MARK_EMPTY</code> symbol is invisible, allowing client code to track the movement of lines. You would also use it if you changed the folding style and wanted one or more of the <code>wxSCI_FOLDERNUM_</code>* markers to have no associated symbol.
</p>
<p>
There are also marker symbols designed for use in the folding margin in a flattened tree style.
</p>
<ul style="list-style-type:none">
<li><code>wxSCI_MARK_BOXMINUS</code>,<br />
<li><code>wxSCI_MARK_BOXMINUSCONNECTED</code>,<br />
<li><code>wxSCI_MARK_BOXPLUS</code>,<br />
<li><code>wxSCI_MARK_BOXPLUSCONNECTED</code>,<br />
<li><code>wxSCI_MARK_CIRCLEMINUS</code>,<br />
<li><code>wxSCI_MARK_CIRCLEMINUSCONNECTED</code>,<br />
<li><code>wxSCI_MARK_CIRCLEPLUS</code>,<br />
<li><code>wxSCI_MARK_CIRCLEPLUSCONNECTED</code>,<br />
<li><code>wxSCI_MARK_LCORNER</code>,<br />
<li><code>wxSCI_MARK_LCORNERCURVE</code>,<br />
<li><code>wxSCI_MARK_TCORNER</code>,<br />
<li><code>wxSCI_MARK_TCORNERCURVE</code>,<br />
<li><code>wxSCI_MARK_VLINE</code>.
</ul>
<p>
Characters can be used as markers by adding the ASCII value of the character to <code>wxSCI_MARK_CHARACTER</code> (10000). For example, to use 'A' (ASCII code 65) as marker number 1 use <code>MarkerDefine (1, wxSCI_MARK_CHARACTER+65)</code>.
</p>
<p>
The marker numbers <code>wxSCI_MARKNUM_FOLDER</code> and <code>wxSCI_MARKNUM_FOLDEROPEN </code> are used for showing that a fold is present and open or closed. Any symbols may be assigned for this purpose although the (<code>wxSCI_MARK_PLUS</code>, <code>wxSCI_MARK_MINUS</code>) pair or the (<code>wxSCI_MARK_ARROW</code>, <code>wxSCI_MARK_ARROWDOWN</code>) pair are good choices. As well as these two, more assignments are needed for the flattened tree style:<br />
<code>wxSCI_MARKNUM_FOLDEREND</code>, <code>wxSCI_MARKNUM_FOLDERMIDTAIL</code>, <code>wxSCI_MARKNUM_FOLDEROPENMID</code>, <code>wxSCI_MARKNUM_FOLDERSUB</code>, and <code>wxSCI_MARKNUM_FOLDERTAIL</code>. The bits used for folding are specified by <code>wxSCI_MASK_FOLDERS</code>, which is commonly used as an argument to <code>SetMarginMask</code> when defining a margin to be used for folding.
</p>
<p>
This table shows which <code>wxSCI_MARK_</code>* symbols should be assigned to which <code>wxSCI_MARKNUM_</code>* marker numbers to obtain four folding styles: Arrow (mimics Macintosh), plus/minus shows folded lines as '+' and opened folds as '-', Circle tree, Box tree.
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Markers used for folding"><thead align="left">
<tr>
  <th><code>wxSCI_MARKNUM_</code>*</th>
  <th>Arrow</th>
  <th>Plus/minus</th>
  <th>Circle tree</th>
  <th>Box tree</th>
</tr>
</thead><tbody valign="top">
<tr>
  <th align="left"><code>FOLDEROPEN</code></th>
  <td><code>ARROWDOWN</code></td>
  <td><code>MINUS</code></td>
  <td><code>CIRCLEMINUS</code></td>
  <td><code>BOXMINUS</code></td>
</tr><tr>
  <th align="left"><code>FOLDER</code></th>
  <td><code>ARROW</code></td>
  <td><code>PLUS</code></td>
  <td><code>CIRCLEPLUS</code></td>
  <td><code>BOXPLUS</code></td>
</tr><tr>
  <th align="left"><code>FOLDERSUB</code></th>
  <td><code>EMPTY</code></td>
  <td><code>EMPTY</code></td>
  <td><code>VLINE</code></td>
  <td><code>VLINE</code></td>
</tr><tr>
  <th align="left"><code>FOLDERTAIL</code></th>
  <td><code>EMPTY</code></td>
  <td><code>EMPTY</code></td>
  <td><code>LCORNERCURVE</code></td>
  <td><code>LCORNER</code></td>
</tr><tr>
  <th align="left"><code>FOLDEREND</code></th>
  <td><code>EMPTY</code></td>
  <td><code>EMPTY</code></td>
  <td><code>CIRCLEPLUSCONNECTED</code></td>
  <td><code>BOXPLUSCONNECTED</code></td>
</tr><tr>
  <th align="left"><code>FOLDEROPENMID</code></th>
  <td><code>EMPTY</code></td>
  <td><code>EMPTY</code></td>
  <td><code>CIRCLEMINUSCONNECTED</code></td>
  <td><code>BOXMINUSCONNECTED</code></td>
</tr><tr>
  <th align="left"><code>FOLDERMIDTAIL</code></th>
  <td><code>EMPTY</code></td>
  <td><code>EMPTY</code></td>
  <td><code>TCORNERCURVE</code></td>
  <td><code>TCORNER</code></td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="MarkerSetForeground">void MarkerSetForeground (int markerNumber, const wxColour& fore)</a><br />
    <a name="MarkerSetBackground">void MarkerSetBackground (int markerNumber, const wxColour& back)</a></h4>
<p>
Set the foreground and background colour of a marker number. Default colours for foreground is <code>black</code>, for background is <code>white</code>. Usually but not always the foreground colour is used to outline a marker symbol and the background colour is used to fill the symbol. Sometimes only one colour is used. The background is also used as the text background when the marker isn't displayed as a margin.
</p>

<div class="divider2"></div>
<h4><a name="MarkerSetAlpha">void MarkerSetAlpha (int markerNumber, int alpha)</a></h4>
<p>
When markers are drawn in the content area, either because there is no margin for them or they are of <code>wxSCI_MARK_BACKGROUND</code> type, they may be drawn translucently by setting an alpha value.
</p>

<div class="divider2"></div>
<h4><a name="MarkerAdd">int MarkerAdd (int line, int markerNumber)</a></h4>
<p>
Adds marker number <code>markerNumber</code> to a line. It returns -1 if this fails (illegal line number, out of memory) or it returns a marker handle number that identifies the added marker. You can use this returned handle with <a class="message" href="#MarkerLineFromHandle"><code>MarkerLineFromHandle</code></a> to find where a marker is after moving or combining lines and with <a class="message" href="#MarkerDeleteHandle"><code>MarkerDeleteHandle</code></a> to delete the marker based on its handle. It does not check the value of markerNumber, nor does it check if the line already contains the marker.
</p>

<div class="divider2"></div>
<h4><a name="MarkerAddSet">int MarkerAddSet (int line, int markerSet)</a></h4>
<p>
MarkerAddSet can add one or more markers to a line with a single call, specified in the same "one-bit-per-marker" 32-bit integer format returned by <a class="message" href="#MarkerGet"><code>MarkerGet</code></a> (and used by the mask-based marker search functions <a class="message" href="#MarkerNext"><code>MarkerNext</code></a> and <a class="message" href="#MarkerPrevious"><code>MarkerPrevious</code></a>). As with <a class="message" href="#MarkerAdd"><code>MarkerAdd</code></a>, no check is made to see if any of the markers are already present on the targeted line.
</p>

<div class="divider2"></div>
<h4><a name="MarkerDelete">void MarkerDelete (int line, int markerNumber)</a></h4>
<p>
This searches the given line number for the given marker number and deletes it if it is present. If you added the same marker more than once to the line, this will delete one copy each time it is used. If you pass in a marker number of -1, all markers are deleted from the line.
</p>

<div class="divider2"></div>
<h4><a name="MarkerDeleteAll">void MarkerDeleteAll (int markerNumber)</a></h4>
<p>
This removes markers of the given number from all lines. If markerNumber is -1, it deletes all markers from all lines.
</p>

<div class="divider2"></div>
<h4><a name="MarkerGet">int MarkerGet (int line)</a></h4>
<p>
This returns a 32-bit integer that indicates which markers were present on the line. Bit 0 is set if marker 0 is present, bit 1 for marker 1 and so on.
</p>

<div class="divider2"></div>
<h4><a name="MarkerNext">int MarkerNext (int lineStart, int markerMask)</a><br />
    <a name="MarkerPrevious">int MarkerPrevious (int lineStart, int markerMask)</a></h4>
<p>
Search efficiently for lines that include a given set of markers. The search starts at line number <code>lineStart</code> and continues forwards to the end of the file (<code>MarkerNext</code>) or backwards to the start of the file (<code>MarkerPrevious</code>). The <code>markerMask</code> argument should have one bit set for each marker you wish to find. Set bit 0 to find marker 0, bit 1 for marker 1 and so on. Returns the line number of the first line that contains one of the markers in <code>markerMask</code> or -1 if no marker is found.
</p>

<div class="divider2"></div>
<h4><a name="MarkerLineFromHandle">int MarkerLineFromHandle (int handle)</a></h4>
<p>
The <code>handle</code> argument is an identifier for a marker returned by <a class="message" href="#MarkerAdd"><code>MarkerAdd</code></a>. This function searches the document for the marker with this handle and returns the line number that contains it or wxSCI_INVALID_POSITION if it is not found.
</p>

<div class="divider2"></div>
<h4><a name="MarkerDeleteHandle">void MarkerDeleteHandle (int handle)</a></h4>
<p>
The <code>handle</code> argument is an identifier for a marker returned by <a class="message" href="#MarkerAdd"><code>MarkerAdd</code></a>. This function searches the document for the marker with this handle and deletes the marker if it is found.
</p>

<div class="divider1"></div>
<h3 id="Indicators">Indicators</h3>

<p>
By default, Scintilla organizes the style byte associated with each text byte as 5 bits of style information (for 32 styles) and 3 bits of indicator information for 3 in dependent indicators so that, for example, syntax errors, deprecated names and bad indentation could all be displayed at once. Indicators may be displayed as simple underlines, squiggly underlines, a line of small 'T' shapes, a line of diagonal hatching, a strike-out or a rectangle around the text.
</p>
<p>
The indicators are set using <a class="message" href="#StartStyling"><code>StartStyling</code></a> with a <code>wxSCI_INDICS_MASK</code> mask and <a class="message" href="#SetStyling"><code>SetStyling</code></a> with the values <code>INDIC0_MASK</code>, <code>INDIC1_MASK</code> and <code>INDIC2_MASK</code>.
</p>
<p>If you are using indicators in a buffer that has a lexer active (see <a class="message" href="#SetLexer"><code>SetLexer</code></a>), you must save lexing state information before setting any indicators and restore it afterwards. Use <a class="message" href="#GetEndStyled"><code>GetEndStyled</code></a> to retrieve the current "styled to" position and <a class="message" href="#StartStyling"><code>StartStyling</code></a> to reset the styling position and mask (<code>0x1f </code> in the default layout of 5 style bits and 3 indicator bits) when you are done.</p>

<p>
The number of bits used for styles can be altered with <a class="message" href="#SetStyleBits"><code>SetStyleBits</code></a> from 0 to 7 bits. The remaining bits can be used for indicators, so there can be from 1 to 8 indicators. However, the <code>wxSCI_INDICS_..._MASK</code> constants defined in <code>Scintilla.h</code> all assume 5 bits of styling information and 3 indicators. If you use a different arrangement, you must define your own constants.
</p>

<p>
The <code>Indicator...</code> allow you to get and set the visual appearance of the indicators. They all use an <code>indicatorNumber</code> argument in the range 0 to 7 to set the indicator to style. With the default settings, only indicators 0, 1 and 2 will have any visible effect.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#IndicatorSetStyle">void IndicatorSetStyle (int indic, int style)</a></li>
<li><a class="message" href="#IndicatorGetStyle">int IndicatorGetStyle (int indic)</a></li>
<li><a class="message" href="#IndicatorSetForeground">void IndicatorSetForeground (int indic, const wxColour& fore)</a></li>
<li><a class="message" href="#IndicatorGetForeground">wxColour IndicatorGetForeground (int indic)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="IndicatorSetStyle">void IndicatorSetStyle (int indic, int style)</a><br />
    <a name="IndicatorGetStyle">int IndicatorGetStyle (int indic)</a></h4>
<p>
Set and get the style for a particular indicator. The indicator styles currently available are:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Indicators"><thead>
<tr>
  <th align="left">Symbol</th>
  <th>Value</th>
  <th align="left">Visual effect</th>
</tr>
</theady>  <tbody valign="top">
<tr>
  <td align="left"><code>INDIC_PLAIN</code></td>
  <td align="center">0</td>
  <td>Underlined with a single, straight line.</td>
</tr><tr>
  <td align="left"><code>INDIC_SQUIGGLE</code></td>
  <td align="center">1</td>
  <td>A squiggly underline.</td>
</tr><tr>
  <td align="left"><code>INDIC_TT</code></td>
  <td align="center">2</td>
  <td>A line of small T shapes.</td>
</tr><tr>
  <td align="left"><code>INDIC_DIAGONAL</code></td>
  <td align="center">3</td>
  <td>Diagonal hatching.</td>
</tr><tr>
  <td align="left"><code>INDIC_STRIKE</code></td>
  <td align="center">4</td>
  <td>Strike out.</td>
</tr><tr>
  <td align="left"><code>INDIC_HIDDEN</code></td>
  <td align="center">5</td>
  <td>An indicator with no visual effect.</td>
</tr><tr>
  <td align="left"><code>INDIC_BOX</code></td>
  <td align="center">6</td>
  <td>A rectangle around the text.</td>
</tr>
</tbody></table>

<p>
The default indicator styles are equivalent to:<br />
<code>IndicatorSetStyle (0, INDIC_SQUIGGLE);</code><br />
<code>IndicatorSetStyle (1, INDIC_TT);</code><br />
<code>IndicatorSetStyle (2, INDIC_PLAIN);</code>
</p>

<div class="divider2"></div>
<h4><a name="IndicatorSetForeground">void IndicatorSetForeground (int indic, const wxColour& fore)</a><br />
    <a name="IndicatorGetForeground">wxColour IndicatorGetForeground (int indic)</a></h4>
<p>
Set and get the colour used to draw an indicator. The default indicator colours are equivalent to:<br />
<code>IndicatorSetForeground (0, 0x007f00);</code> (dark green)<br />
<code>IndicatorSetForeground (1, 0xff0000);</code> (light blue)<br />
<code>IndicatorSetForeground (2, 0x0000ff);</code> (light red)
</p>

<div class="divider1"></div>
<h3 id="Autocompletion">Autocompletion</h3>

<p>
Autocompletion displays a list box showing likely identifiers based upon the users typing. The user chooses the currently selected item by pressing the TAB character or another character that is a member of the fillup character set defined with <code>AutoCompSetFillUps</code>. Autocompletion is triggered by your application. For example, in C if you detect that the user has just typed <code>fred.</code> you could look up <code>fred</code>, and if it has a known list of members, you could offer them in an autocompletion list. Alternatively, you could monitor the user's typing and offer a list of likely items once their typing has narrowed down the choice to a reasonable list. As yet another alternative, you could define a key code to activate the list.
</p>
<p>
To make use of autocompletion you must monitor each character added to the document. See <code>SciTEBase::CharAdded()</code> in SciTEBase.cxx for an example of autocompletion.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#AutoCompShow">void AutoCompShow (int lenEntered, const wxString& itemList)</a></li>
<li><a class="message" href="#AutoCompCancel">void AutoCompCancel()</a></li>
<li><a class="message" href="#AutoCompActive">bool AutoCompActive()</a></li>
<li><a class="message" href="#AutoCompPosStart">int AutoCompPosStart()</a></li>
<li><a class="message" href="#AutoCompComplete">void AutoCompComplete()</a></li>
<li><a class="message" href="#AutoCompStops">void AutoCompStops (const wxString& characterSet)</a></li>
<li><a class="message" href="#AutoCompSetSeparator">void AutoCompSetSeparator (int separatorCharacter)</a></li>
<li><a class="message" href="#AutoCompGetSeparator">int AutoCompGetSeparator()</a></li>
<li><a class="message" href="#AutoCompSelect">void AutoCompSelect (const wxString& text)</a></li>
<li><a class="message" href="#AutoCompGetCurrent">int AutoCompGetCurrent()</a></li>
<li><a class="message" href="#AutoCompSetCancelAtStart">void AutoCompSetCancelAtStart (bool cancel)</a></li>
<li><a class="message" href="#AutoCompGetCancelAtStart">bool AutoCompGetCancelAtStart()</a></li>
<li><a class="message" href="#AutoCompSetFillUps">void AutoCompSetFillUps (const wxString& characterSet)</a></li>
<li><a class="message" href="#AutoCompSetChooseSingle">void AutoCompSetChooseSingle (bool chooseSingle)</a></li>
<li><a class="message" href="#AutoCompGetChooseSingle">bool AutoCompGetChooseSingle()</a></li>
<li><a class="message" href="#AutoCompSetIgnoreCase">void AutoCompSetIgnoreCase (bool ignoreCase)</a></li>
<li><a class="message" href="#AutoCompGetIgnoreCase">bool AutoCompGetIgnoreCase()</a></li>
<li><a class="message" href="#AutoCompSetAutoHide">void AutoCompSetAutoHide (bool autoHide)</a></li>
<li><a class="message" href="#AutoCompGetAutoHide">bool AutoCompGetAutoHide()</a></li>
<li><a class="message" href="#AutoCompSetDropRestOfWord">void AutoCompSetDropRestOfWord (bool dropRestOfWord)</a></li>
<li><a class="message" href="#AutoCompGetDropRestOfWord">bool AutoCompGetDropRestOfWord()</a></li>
<li><a class="message" href="#RegisterImage">void RegisterImage (int type, const wxBitmap& bmp)</a></li>
<li><a class="message" href="#ClearRegisteredImages">void ClearRegisteredImages()</a></li>
<li><a class="message" href="#AutoCompSetTypeSeparator">void AutoCompSetTypeSeparator (int separatorCharacter)</a></li>
<li><a class="message" href="#AutoCompGetTypeSeparator">int AutoCompGetTypeSeparator()</a></li>
<li><a class="message" href="#AutoCompSetMaxWidth">void AutoCompSetMaxWidth (int characterCount)</a></li>
<li><a class="message" href="#AutoCompGetMaxWidth">int AutoCompGetMaxWidth()</a></li>
<li><a class="message" href="#AutoCompSetMaxHeight">void AutoCompSetMaxHeight (int rowCount)</a></li>
<li><a class="message" href="#AutoCompGetMaxHeight">int AutoCompGetMaxHeight()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="AutoCompShow">void AutoCompShow (int lenEntered, const wxString& itemList)</a></h4>
<p>
Causes a list to be displayed. <code>lenEntered</code> is the number of characters of the word already entered and <code>list</code> is the list of words separated by separator characters. The initial separator character is a space but this can be set or got with <a class="message" href="#AutoCompSetSeparator"><code>AutoCompSetSeparator</code></a> and <a class="message" href="#AutoCompGetSeparator"><code>AutoCompGetSeparator</code></a>.
</p>
<p>
The list of words should be in sorted order. If set to ignore case mode with <a class="message" href="#AutoCompSetIgnoreCase"><code>AutoCompSetIgnoreCase</code></a>, then strings are matched after being converted to upper case. One result of this is that the list should be sorted with the punctuation characters '[', '\', ']', '^', '_', and '`' sorted after letters.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompCancel">void AutoCompCancel()</a></h4>
<p>
Cancels any displayed autocompletion list. When in autocompletion mode, the list should disappear when the user types a character that can not be part of the autocompletion, such as '.', '(' or '[' when typing an identifier. A set of characters that will cancel autocompletion can be specified with <a class="message" href="#AutoCompStops"><code>AutoCompStops</code></a>.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompActive">bool AutoCompActive()</a></h4>
<p>
Returns true if there is an active autocompletion list, otherwise false.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompPosStart">int AutoCompPosStart()</a></h4>
<p>
Returns the value of the current position when <code>AutoCompShow</code> started display of the list.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompComplete">void AutoCompComplete()</a></h4>
<p>
Completes an autocompletion operation. Internally, this is caused by clicking TAB, ENTER key;, or one of the characters specified by <a class="message" href="#AutoCompSetFillUps"><code>AutoCompSetFillUps</code></a>. AutoCompComplete allows you to complete the operation programmatically.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompStops">void AutoCompStops (const wxString& characterSet)</a></h4>
<p>
The <code>characterSet</code> argument is a string containing a list of characters that will automatically cancel the autocompletion list. When you start the editor, this list is empty.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetSeparator">void AutoCompSetSeparator (int separatorCharacter)</a><br />
    <a name="AutoCompGetSeparator">int AutoCompGetSeparator()</a></h4>
<p>
These set and get the separator character used to separate words in the <code>AutoCompShow</code> list. The default is the space character.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSelect">void AutoCompSelect (const wxString& text)</a><br />
    <a name="AutoCompGetCurrent">AutoCompGetCurrent</a></h4>
<p>
Selects an item in the autocompletion list. It searches the list of words for the first that matches <code>select</code>. By default, comparisons are case sensitive, but you can change this with <a class="message" href="#AutoCompSetIgnoreCase"><code>AutoCompSetIgnoreCase</code></a>. The match is character by character for the length of the <code>select</code> string. That is, if select is "Fred" it will match "Frederick" if this is the first item in the list that begins with "Fred". If an item is found, it is selected. If the item is not found, the autocompletion list closes if auto-hide is true (see <a class="message" href="#AutoCompSetAutoHide"><code>AutoCompSetAutoHide</code></a>). The current selection can be retrieved with <code>AutoCompGetCurrent</code>.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetCancelAtStart">void AutoCompSetCancelAtStart (bool cancel)</a><br />
    <a name="AutoCompGetCancelAtStart">bool AutoCompGetCancelAtStart()</a></h4>
<p>
The default behavior is for the list to be cancelled if the caret moves before the location it was at when the list was displayed. By calling with a <code>false</code> argument, the list is not cancelled until the caret moves before the first character of the word being completed.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetFillUps">void AutoCompSetFillUps (const wxString& characterSet)</a></h4>
<p>
If a fillup character is typed with an autocompletion list active, the currently selected item in the list is added into the document, then the fillup character is added. Common fillup characters are '(', '[' and '.' but others are possible depending on the language. By default, no fillup characters are set.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetChooseSingle">void AutoCompSetChooseSingle (bool chooseSingle)/b><br />
    <a name="AutoCompGetChooseSingle">bool AutoCompGetChooseSingle()</a></h4>
<p>
If you use <code>AutoCompSetChooseSingle(1)</code> and a list has only one item, it is automatically added and no list is displayed. The default is to display the list even if there is only a single item.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetIgnoreCase">void AutoCompSetIgnoreCase (bool ignoreCase)</a><br />
    <a name="AutoCompGetIgnoreCase">bool AutoCompGetIgnoreCase()</a></h4>
<p>
By default, matching of characters to list members is case sensitive. Let you set and get case sensitivity.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetAutoHide">void AutoCompSetAutoHide (bool autoHide)</a><br />
    <a name="AutoCompGetAutoHide">bool AutoCompGetAutoHide()</a></h4>
<p>
By default, the list is cancelled if there are no viable matches (the user has typed characters that no longer match a list entry). If you want to keep displaying the original list, set <code>autoHide</code> to <code>false</code>. This also effects <a class="message" href="#AutoCompSelect"><code>AutoCompSelect</code></a>.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetDropRestOfWord">void AutoCompSetDropRestOfWord (bool dropRestOfWord)</a><br />
    <a name="AutoCompGetDropRestOfWord">bool AutoCompGetDropRestOfWord()</a></h4>
<p>
When an item is selected, any word characters following the caret are first erased if <code>dropRestOfWord</code> is set <code>true</code>. The default is <code>false</code>.
</p>

<div class="divider2"></div>
<h4><a name="RegisterImage">void RegisterImage (int type, const wxBitmap& bmp)</a><br />
    <a name="ClearRegisteredImages">void ClearRegisteredImages()</a><br />
    <a name="AutoCompSetTypeSeparator">void AutoCompSetTypeSeparator (int separatorCharacter)</a><br />
    <a name="AutoCompGetTypeSeparator">int AutoCompGetTypeSeparator()</a></h4>
<p>
Autocompletion list items may display an image as well as text. Each image is first registered with an integer type. Then this integer is included in the text of the list separated by a '?' from the text. For example, "fclose?2 fopen" displays image 2 before the string "fclose" and no image before "fopen". The images are in XPM format as is described for <a class="message" href="#MarkerDefineBitmap"><code>MarkerDefineBitmap</code></a> The set of registered images can be cleared with <code>ClearRegisteredImages</code> and the '?' separator changed with <code>AutoCompSetTypeSeparator</code>.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetMaxWidth">void AutoCompSetMaxWidth (int characterCount)</a><br />
    <a name="AutoCompGetMaxWidth">int AutoCompGetMaxWidth()</a></h4>
<p>
Get or set the maximum number of rows that will be visible in an autocompletion list. If there are more rows in the list, then a vertical scrollbar is shown. The default is 5.
</p>

<div class="divider2"></div>
<h4><a name="AutoCompSetMaxHeight">void AutoCompSetMaxHeight (int rowCount)</a><br />
    <a name="AutoCompGetMaxHeight">int AutoCompGetMaxHeight()</a></h4>
<p>
Get or set the maximum width of an autocompletion list expressed as the number of characters in the longest item that will be totally visible. If zero (the default) then the list's width is calculated to fit the item with the most characters. Any items that cannot be fully displayed within the available width are indicated by the presence of ellipsis.
</p>

<div class="divider1"></div>
<h3 id="UserLists">User lists</h3>

<p>
User lists use the same internal mechanisms as autocompletion lists, and all the calls
listed for autocompletion work on them; you cannot display a user list at the same time as an autocompletion list is active. They differ in the following respects:<br />
o The <code><a class="message" href="#AutoCompSetChooseSingle">AutoCompSetChooseSingle</a></code> has no effect.<br />
o When the user makes a selection you are sent a <code><a class="message" href="#wxEVT_SCI_USERLISTSELECTION">wxEVT_SCI_USERLISTSELECTION</a></code> <a class="jump" href="#Notifications">notification message</a>.
</p>
<p>
BEWARE: if you have set fillup characters or stop characters, these will still be active with the user list, and may result in items being selected or the user list cancelled due to the user typing into the editor.
</p>

<div class="divider2"></div>
<h4><a name="UserListShow">void UserListShow (int listType, const wxString& itemList)</a></h4>
<p>
The <code>listType</code> parameter is returned to the container as the <code>wParam</code> field of the <a class="message" href="#SCNotification"><code>SCNotification</code></a> structure. It must be greater than 0 as this is how Scintilla tells the difference between an autocompletion list and a user list. If you have different types of list, for example a list of buffers and a list of macros, you can use <code>listType</code> to tell which one has returned a selection.
</p>

<div class="divider1"></div>
<h3 id="CallTips">Call tips</h3>

<p>
Call tips are small windows displaying the arguments to a function and are displayed after the user has typed the name of the function. They normally display characters using the font facename, size and character set defined by <a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_DEFAULT</code></a>. You can choose to use <a class="message" href="#StyleCallTip"><code>wxSCI_STYLE_CALLTIP</code></a> to define the facename, size, foreground and background colours and character set with <a class="message" href="#CallTipUseStyle"><code>CallTipUseStyle</code></a>. This also enables support for Tab characters. There is some interaction between call tips and autocompletion lists in that showing a call tip cancels any active autocompletion list, and vice versa.
</p>
<p>
Call tips can highlight part of the text within them. You could use this to highlight the current argument to a function by counting the number of commas (or whatever separator your language uses). See <code>SciTEBase::CharAdded()</code> in <code>SciTEBase.cxx</code> for an example of call tip use.
</p>
<p>
The mouse may be clicked on call tips and this causes a <code><a class="message" href="#wxEVT_SCI_CALLTIP_CLICK">wxEVT_SCI_CALLTIP_CLICK</a></code> notification to be sent to the container. Small up an down arrows may be displayed within a call tip by, respectively, including the characters '\001', or '\002'. This is useful for showing that there are overloaded variants of one function name and that the user can click on the arrows to cycle through the overloads.
</p>
<p>
Alternatively, call tips can be displayed when you leave the mouse pointer for a while over a word in response to the <code><a class="message" href="#wxEVT_SCI_DWELLSTART">wxEVT_SCI_DWELLSTART</a></code> <a class="jump" href="#Notifications">notification</a> and cancelled in response to <code><a class="message" href="#wxEVT_SCI_DWELLEND">wxEVT_SCI_DWELLEND</a></code>. This method could be used in a debugger to give the value of a variable, or during editing to give information about the word under the pointer.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#CallTipShow">void CallTipShow (int pos, const wxString& definition)</a></li>
<li><a class="message" href="#CallTipCancel">void CallTipCancel()</a></li>
<li><a class="message" href="#CallTipActive">bool CallTipActive()</a></li>
<li><a class="message" href="#CallTipPosAtStart">int CallTipPosAtStart()</a></li>
<li><a class="message" href="#CallTipSetHighlight">void CallTipSetHighlight (int startPos, int endPos)</a></li>
<li><a class="message" href="#CallTipSetBackground">void CallTipSetBackground (const wxColour& back)</a></li>
<li><a class="message" href="#CallTipSetForeground">void CallTipSetForeground (const wxColour& fore)</a></li>
<li><a class="message" href="#CallTipSetForegroundHighlight">void CallTipSetForegroundHighlight (const wxColour& fore)</a></li>
<li><a class="message" href="#CallTipUseStyle">void CallTipUseStyle (int tabSize)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="CallTipShow">void CallTipShow (int pos, const wxString& definition)</a></h4>
<p>
Starts the process by displaying the call tip window. If a call tip is already active, this has no effect.<br />
<code>posStart</code> is the position in the document at which to align the call tip. The call tip text is aligned to start 1 line below this character unless you have included up and/or down arrows in the call tip text in which case the tip is aligned to the right-hand edge of the rightmost arrow. The assumption is that you will start the text with something like "\001 1 of 3 \002".<br />
<code>definition</code> is the call tip text. This can contain multiple lines separated by '\n' (Line Feed, ASCII code 10) characters. Do not include '\r' (Carriage Return, ASCII code 13), as this will most likely print as an empty box. '\t' (Tab, ASCII code 9) is supported if you set a tabsize with <a class="message" href="#CallTipUseStyle"><code>CallTipUseStyle</code></a>.
</p>

<div class="divider2"></div>
<h4><a name="CallTipCancel">void CallTipCancel()</a></h4>
<p>
Cancels any displayed call tip. Scintilla will also cancel call tips for you if you use any keyboard commands that are not compatible with editing the argument list of a function.
</p>

<div class="divider2"></div>
<h4><a name="CallTipActive">bool CallTipActive()</a></h4>
<p>
This returns true if a call tip is active, otherwise false.
</p>

<div class="divider2"></div>
<h4><a name="CallTipPosAtStart">int CallTipPosAtStart()</a></h4>
<p>
Returns the value of the current position when <code>CallTipShow</code> started to display the tip.
</p>

<div class="divider2"></div>
<h4><a name="CallTipSetHighlight">void CallTipSetHighlight (int startPos, int endPos)</a></h4>
<p>
This sets the region of the call tips text to display in a highlighted style. <code>startPos</code> is the zero-based index into the string of the first character to highlight and <code>endPos</code> is the index of the first character after the highlight. <code>endPos</code> must be greater than <code>startPos</code>; <code>endPos-startPos</code> is the number of characters to highlight. Highlights can extend over line ends if this is required.
</p>
<p>
Unhighlighted text is drawn in a mid gray. Selected text is drawn in a dark blue. The background is white. These can be changed with <code>CallTipSetBackground</code>, <code>CallTipSetForeground</code>, and <code>CallTipSetForegroundHighlight</code>.
</p>

<div class="divider2"></div>
<h4><a name="CallTipSetBackground">void CallTipSetBackground (const wxColour& back)</a></h4>
<p>
The background colour of call tips can be set; the default colour is white. It is not a good idea to set a dark colour as the background as the unselected text is drawn in mid gray and the selected text in a dark blue.
</p>

<div class="divider2"></div>
<h4><a name="CallTipSetForeground">void CallTipSetForeground (const wxColour& fore)</a></h4>
<p>
The colour of call tip text can be set; the default colour is mid gray.
</p>

<div class="divider2"></div>
<h4><a name="CallTipSetForegroundHighlight">void CallTipSetForegroundHighlight (const wxColour& fore)</a></h4>
<p>
The colour of highlighted call tip text can be set; the default colour is dark blue.
</p>

<div class="divider2"></div>
<h4><a name="CallTipUseStyle">void CallTipUseStyle (int tabSize)</a></h4>
<p>
This message changes the style used for call tips from <code>wxSCI_STYLE_DEFAULT</code> to <code>wxSCI_STYLE_CALLTIP</code> and sets a tab size in screen pixels. If <code>tabSize</code> is less than 1, Tab characters are not treated specially. Once this call has been used, the call tip foreground and background colours are also taken from the style.
</p>

<div class="divider1"></div>
<h3 id="KeyboardCommands">Keyboard commands</h3>

<p>
To allow the container application to perform any of the actions available to the user with keyboard, all the keyboard actions are commands. They do not take any parameters. These commands are also used when redefining the key bindings with the <a class="message" href="#CmdKeyAssign"><code>CmdKeyAssign</code></a>.
</p>
<table border="0" summary="Keyboard commands"><tbody>
<tr>
  <td><code>wxSCI_CMD_LINEDOWN</code></td>
  <td><code>wxSCI_CMD_LINEDOWNEXTEND</code></td>
  <td><code>wxSCI_CMD_LINEDOWNRECTEXTEND</code></td>
  <td><code>wxSCI_CMD_LINESCROLLDOWN</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_LINEUP</code></td>
  <td><code>wxSCI_CMD_LINEUPEXTEND</code></td>
  <td><code>wxSCI_CMD_LINEUPRECTEXTEND</code></td>
  <td><code>wxSCI_CMD_LINESCROLLUP</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_PARADOWN</code></td>
  <td><code>wxSCI_CMD_PARADOWNEXTEND</code></td>
  <td><code>wxSCI_CMD_PARAUP</code></td>
  <td><code>wxSCI_CMD_PARAUPEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_CHARLEFT</code></td>
  <td><code>wxSCI_CMD_CHARLEFTEXTEND</code></td>
  <td><code>wxSCI_CMD_CHARLEFTRECTEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_CHARRIGHT</code></td>
  <td><code>wxSCI_CMD_CHARRIGHTEXTEND</code></td>
  <td><code>wxSCI_CMD_CHARRIGHTRECTEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_WORDLEFT</code></td>
  <td><code>wxSCI_CMD_WORDLEFTEXTEND</code></td>
  <td><code>wxSCI_CMD_WORDRIGHT</code></td>
  <td><code>wxSCI_CMD_WORDRIGHTEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_WORDLEFTEND</code></td>
  <td><code>wxSCI_CMD_WORDLEFTENDEXTEND</code></td>
  <td><code>wxSCI_CMD_WORDRIGHTEND</code></td>
  <td><code>wxSCI_CMD_WORDRIGHTENDEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_WORDPARTLEFT</code></td>
  <td><code>wxSCI_CMD_WORDPARTLEFTEXTEND</code></td>
  <td><code>wxSCI_CMD_WORDPARTRIGHT</code></td>
  <td><code>wxSCI_CMD_WORDPARTRIGHTEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_HOME</code></td>
  <td><code>wxSCI_CMD_HOMEEXTEND</code></td>
  <td><code>[wxSCI_CMD_HOMERECTEXTEND]</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_HOMEDISPLAY</code></td>
  <td><code>wxSCI_CMD_HOMEDISPLAYEXTEND</code></td>
  <td><code>wxSCI_CMD_HOMEWRAP</code></td>
  <td><code>wxSCI_CMD_HOMEWRAPEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_VCHOME</code></td>
  <td><code>wxSCI_CMD_VCHOMEEXTEND</code></td>
  <td><code>wxSCI_CMD_VCHOMERECTEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_VCHOMEWRAP</code></td>
  <td><code>wxSCI_CMD_VCHOMEWRAPEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_LINEEND</code></td>
  <td><code>wxSCI_CMD_LINEENDEXTEND</code></td>
  <td><code>wxSCI_CMD_LINEENDRECTEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_LINEENDDISPLAY</code></td>
  <td><code>wxSCI_CMD_LINEENDDISPLAYEXTEND</code></td>
  <td><code>wxSCI_CMD_LINEENDWRAP</code></td>
  <td><code>wxSCI_CMD_LINEENDWRAPEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_DOCUMENTSTART</code></td>
  <td><code>wxSCI_CMD_DOCUMENTSTARTEXTEND</code></td>
  <td><code>wxSCI_CMD_DOCUMENTEND</code></td>
  <td><code>wxSCI_CMD_DOCUMENTENDEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_PAGEUP</code></td>
  <td><code>wxSCI_CMD_PAGEUPEXTEND</code></td>
  <td><code>wxSCI_CMD_PAGEUPRECTEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_PAGEDOWN</code></td>
  <td><code>wxSCI_CMD_PAGEDOWNEXTEND</code></td>
  <td><code>wxSCI_CMD_PAGEDOWNRECTEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_STUTTEREDPAGEUP</code></td>
  <td><code>wxSCI_CMD_STUTTEREDPAGEUPEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_STUTTEREDPAGEDOWN</code></td>
  <td><code>wxSCI_CMD_STUTTEREDPAGEDOWNEXTEND</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_DELETEBACK</code></td>
  <td><code>wxSCI_CMD_DELETEBACKNOTLINE</code></td>
  <td><code>wxSCI_CMD_DELWORDLEFT</code></td>
  <td><code>wxSCI_CMD_DELWORDRIGHT</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_DELLINELEFT</code></td>
  <td><code>wxSCI_CMD_DELLINERIGHT</code></td>
  <td><code>wxSCI_CMD_LINEDELETE</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_LINECUT</code></td>
  <td><code>wxSCI_CMD_LINECOPY</code></td>
  <td><code>wxSCI_CMD_LINETRANSPOSE</code></td>
  <td><code>wxSCI_CMD_LINEDUPLICATE</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_LOWERCASE</code></td>
  <td><code>wxSCI_CMD_UPPERCASE</code></td>
  <td><code>wxSCI_CMD_CANCEL</code></td>
  <td><code>wxSCI_CMD_EDITTOGGLEOVERTYPE</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_NEWLINE</code></td>
  <td><code>wxSCI_CMD_FORMFEED</code></td>
  <td><code>wxSCI_CMD_TAB</code></td>
  <td><code>wxSCI_CMD_BACKTAB</code></td>
</tr><tr>
  <td><code>wxSCI_CMD_SELECTIONDUPLICATE</code></td>
</tr>
</tbody></table>
<p>
The <code>wxSCI_CMD_...EXTEND</code> extend the selection.
</p>
<p>
The <code>wxSCI_CMD_...RECTEXTEND</code> extend the rectangular selection (and convert regular selection to rectangular one, if any).
</p>
<p>
The <code>wxSCI_CMD_WORDPART...</code> commands are used to move between word segments marked by capitalisation (aCamelCaseIdentifier) or underscores (an_under_bar_ident).
</p>
<p>
The <code>wxSCI_CMD_HOME...</code> commands move the caret to the start of the line, while the <code>wxSCI_CMD_VCHOME...</code>commands move the caret to the first non-blank character of the line (ie. just after the indentation) unless it is already there; in this case, it acts as wxSCI_CMD_HOME....
</p>
<p>
The <code>wxSCI_CMD_[HOME|LINEEND]DISPLAY...</code> commands are used when in line wrap mode to allow movement to the start or end of display lines as opposed to the normal <code>wxSCI_CMD_[HOME|LINEEND]</code> commands which move to the start or end of document lines.
</p>
<p>
The <code>wxSCI_CMD_[[VC]HOME|LINEEND]WRAP...</code> commands are like their namesakes <code>wxSCI_CMD_[[VC]HOME|LINEEND]...</code> except they behave differently when word-wrap is enabled:  They go first to the start / end of the display line, like <code>wxSCI_CMD_[HOME|LINEEND]DISPLAY...</code>,  but if the cursor is already at the point, it goes on to the start or end of the document line,  as appropriate for <code>wxSCI_CMD_[[VC]HOME|LINEEND]...</code>.
 </p>

<div class="divider1"></div>
<h3 id="KeyBindings">Key bindings</h3>

<p>
There is a default binding of keys to commands that is defined in the table below. This table maps key definitions to <code>wxSCI_CMD_...</code> with no parameters (mostly the <a class="jump" href="#KeyboardCommands">keyboard commands</a> discussed above, but any Scintilla command that has no arguments can be mapped). You can change the mapping to suit your own rquirements.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#CmdKeyAssign">void CmdKeyAssign (int key, int modifiers, int cmd)</a></li>
<li><a class="message" href="#CmdKeyClear">void CmdKeyClear (int key, int modifiers)</a></li>
<li><a class="message" href="#CmdKeyClearAll">void CmdKeyClearAll()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="keyDefinition">keyDefinition</a></h4>
<p>
A key definition contains the key code in the low 16-bits and the key modifiers in the high 16-bits. To combine <code>keyCode</code> and <code>keyMod</code> set:<br />
<code>keyDefinition = keyCode + (keyMod &lt;&lt; 16)</code>
</p>
<p>
The key code is a visible or control character or a key from the <code>wxSCI_KEY_...</code> enumeration, which contains:
</p>
<ul style="list-style-type:none">
<li><code>wxSCI_KEY_ADD</code></li>
<li><code>wxSCI_KEY_BACK</code></li>
<li><code>wxSCI_KEY_DELETE</code></li>
<li><code>wxSCI_KEY_DIVIDE</code></li>
<li><code>wxSCI_KEY_DOWN</code></li>
<li><code>wxSCI_KEY_END</code></li>
<li><code>wxSCI_KEY_ESCAPE</code></li>
<li><code>wxSCI_KEY_HOME</code></li>
<li><code>wxSCI_KEY_INSERT</code></li>
<li><code>wxSCI_KEY_LEFT</code></li>
<li><code>wxSCI_KEY_NEXT</code> (Page Down)</li>
<li><code>wxSCI_KEY_PRIOR</code> (Page Up)</li>
<li><code>wxSCI_KEY_RETURN</code></li>
<li><code>wxSCI_KEY_RIGHT</code></li>
<li><code>wxSCI_KEY_SUBTRACT</code></li>
<li><code>wxSCI_KEY_TAB</code></li>
<li><code>wxSCI_KEY_UP</code></li>
</ul>
<p>
The modifiers are a combination of zero or more of <code>wxSCI_SCMOD_ALT</code>, <code>wxSCI_SCMOD_CTRL</code>, and <code>wxSCI_SCMOD_SHIFT</code>. If you are building a table, you might want to use <code>wxSCI_SCMOD_NULL</code> to mean no modifiers.
</p>
<table border="0" summary="Key bindings"><tbody align="left">
<tr>
  <th>Key</th>
  <th>Modifiers</th>
  <th>Command</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td><code>DOWN</code></td>
  <td><code>NULL</code></td>
  <td><code>LINEDOWN</code></td>
</tr><tr>
  <td><code>DOWN</code></td>
  <td><code>SHIFT</code></td>
  <td><code>LINEDOWNEXTEND</code></td>
</tr><tr>
  <td><code>DOWN</code></td>
  <td><code></code></td>
  <td><code></code></td>
</tr><tr>
  <td><code>DOWN</code></td>
  <td><code>CTRL</code></td>
  <td><code>LINESCROLLDOWN</code></td>
</tr><tr>
  <td><code>DOWN</code></td>
  <td><code>ALT+SHIFT</code></td>
  <td><code>LINEDOWNRECTEXTEND</code></td>
</tr><tr>
  <td><code>UP</code></td>
  <td><code>NULL</code></td>
  <td><code>LINEUP</code></td>
</tr><tr>
  <td><code>UP</code></td>
  <td><code>SHIFT</code></td>
  <td><code>LINEUPEXTEND</code></td>
</tr><tr>
  <td><code>UP</code></td>
  <td><code>CTRL</code></td>
  <td><code>LINESCROLLUP</code></td>
</tr><tr>
  <td><code>UP</code></td>
  <td><code>ALT+SHIFT</code></td>
  <td><code>LINEUPRECTEXTEND</code></td>
</tr><tr>
  <td><code>LEFT</code></td>
  <td><code>NULL</code></td>
  <td><code>CHARLEFT</code></td>
</tr><tr>
  <td><code>LEFT</code></td>
  <td><code>SHIFT</code></td>
  <td><code>CHARLEFTEXTEND</code></td>
</tr><tr>
  <td><code>LEFT</code></td>
  <td><code>CTRL</code></td>
  <td><code>WORDLEFT</code></td>
</tr><tr>
  <td><code>LEFT</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>WORDLEFTEXTEND</code></td>
</tr><tr>
  <td><code>LEFT</code></td>
  <td><code>ALT+SHIFT</code></td>
  <td><code>CHARLEFTRECTEXTEND</code></td>
</tr><tr>
  <td><code>RIGHT</code></td>
  <td><code>NULL</code></td>
  <td><code>CHARRIGHT</code></td>
</tr><tr>
  <td><code>RIGHT</code></td>
  <td><code>SHIFT</code></td>
  <td><code>CHARRIGHTEXTEND</code></td>
</tr><tr>
  <td><code>RIGHT</code></td>
  <td><code>CTRL</code></td>
  <td><code>WORDRIGHT</code></td>
</tr><tr>
  <td><code>RIGHT</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>WORDRIGHTEXTEND</code></td>
</tr><tr>
  <td><code>RIGHT</code></td>
  <td><code>ALT+SHIFT</code></td>
  <td><code>CHARRIGHTRECTEXTEND</code></td>
</tr><tr>
  <td><code>HOME</code></td>
  <td><code>NULL</code></td>
  <td><code>VCHOME</code></td>
</tr><tr>
  <td><code>HOME</code></td>
  <td><code>SHIFT</code></td>
  <td><code>VCHOMEEXTEND</code></td>
</tr><tr>
  <td><code>HOME</code></td>
  <td><code>ALT+SHIFT</code></td>
  <td><code>VCHOMERECTEXTEND</code></td>
</tr><tr>
  <td><code>HOME</code></td>
  <td><code>CTRL</code></td>
  <td><code>DOCUMENTSTART</code></td>
</tr><tr>
  <td><code>HOME</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>DOCUMENTSTARTEXTEND</code></td>
</tr><tr>
  <td><code>HOME</code></td>
  <td><code>ALT</code></td>
  <td><code>HOMEDISPLAY</code></td>
</tr><tr>
  <td><code>END</code></td>
  <td><code>NULL</code></td>
  <td><code>LINEEND</code></td>
</tr><tr>
  <td><code>END</code></td>
  <td><code>SHIFT</code></td>
  <td><code>LINEENDEXTEND</code></td>
</tr><tr>
  <td><code>END</code></td>
  <td><code>ALT+SHIFT</code></td>
  <td><code>LINEENDRECTEXTEND</code></td>
</tr><tr>
  <td><code>END</code></td>
  <td><code>CTRL</code></td>
  <td><code>DOCUMENTEND</code></td>
</tr><tr>
  <td><code>END</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>DOCUMENTENDEXTEND</code></td>
</tr><tr>
  <td><code>END</code></td>
  <td><code>ALT</code></td>
  <td><code>LINEENDDISPLAY</code></td>
</tr><tr>
  <td><code>PRIOR</code></td>
  <td><code>NULL</code></td>
  <td><code>PAGEUP</code></td>
</tr><tr>
  <td><code>PRIOR</code></td>
  <td><code>SHIFT</code></td>
  <td><code>PAGEUPEXTEND</code></td>
</tr><tr>
  <td><code>PRIOR</code></td>
  <td><code>ALT+SHIFT</code></td>
  <td><code>PAGEUPRECTEXTEND</code></td>
</tr><tr>
  <td><code>NEXT</code></td>
  <td><code>NULL</code></td>
  <td><code>PAGEDOWN</code></td>
</tr><tr>
  <td><code>NEXT</code></td>
  <td><code>SHIFT</code></td>
  <td><code>PAGEDOWNEXTEND</code></td>
</tr><tr>
  <td><code>NEXT</code></td>
  <td><code>ALT+SHIFT</code></td>
  <td><code>PAGEDOWNRECTEXTEND</code></td>
</tr><tr>
  <td><code>'['</code></td>
  <td><code>CTRL</code></td>
  <td><code>PARAUP</code></td>
</tr><tr>
  <td><code>'['</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>PARAUPEXTEND</code></td>
</tr><tr>
  <td><code>']'</code></td>
  <td><code>CTRL</code></td>
  <td><code>PARADOWN</code></td>
</tr><tr>
  <td><code>']'</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>PARADOWNEXTEND</code></td>
</tr><tr>
  <td><code>'/'</code></td>
  <td><code>CTRL</code></td>
  <td><code>WORDPARTLEFT</code></td>
</tr><tr>
  <td><code>'/'</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>WORDPARTLEFTEXTEND</code></td>
</tr><tr>
  <td><code>'\'</code></td>
  <td><code>CTRL</code></td>
  <td><code>WORDPARTRIGHT</code></td>
</tr><tr>
  <td><code>'\'</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>WORDPARTRIGHTEXTEND</code></td>
</tr><tr>
  <td><code>DELETE</code></td>
  <td><code>NULL</code></td>
  <td><code>CLEAR</code></td>
</tr><tr>
  <td><code>DELETE</code></td>
  <td><code>SHIFT</code></td>
  <td><code>CUT</code></td>
</tr><tr>
  <td><code>DELETE</code></td>
  <td><code>CTRL</code></td>
  <td><code>DELWORDRIGHT</code></td>
</tr><tr>
  <td><code>DELETE</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>DELLINERIGHT</code></td>
</tr><tr>
  <td><code>INSERT</code></td>
  <td><code>NULL</code></td>
  <td><code>EDITTOGGLEOVERTYPE</code></td>
</tr><tr>
  <td><code>INSERT</code></td>
  <td><code>SHIFT</code></td>
  <td><code>PASTE</code></td>
</tr><tr>
  <td><code>INSERT</code></td>
  <td><code>CTRL</code></td>
  <td><code>COPY</code></td>
</tr><tr>
  <td><code>ESCAPE</code></td>
  <td><code>NULL</code></td>
  <td><code>CANCEL</code></td>
</tr><tr>
  <td><code>BACK</code></td>
  <td><code>NULL</code></td>
  <td><code>DELETEBACK</code></td>
</tr><tr>
  <td><code>BACK</code></td>
  <td><code>SHIFT</code></td>
  <td><code>DELETEBACK</code></td>
</tr><tr>
  <td><code>BACK</code></td>
  <td><code>CTRL</code></td>
  <td><code>DELWORDLEFT</code></td>
</tr><tr>
  <td><code>BACK</code></td>
  <td><code>ALT</code></td>
  <td><code>UNDO</code></td>
</tr><tr>
  <td><code>BACK</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>DELLINELEFT</code></td>
</tr><tr>
  <td><code>TAB</code></td>
  <td><code>NULL</code></td>
  <td><code>TAB</code></td>
</tr><tr>
  <td><code>TAB</code></td>
  <td><code>SHIFT</code></td>
  <td><code>BACKTAB</code></td>
</tr><tr>
  <td><code>RETURN</code></td>
  <td><code>NULL</code></td>
  <td><code>NEWLINE</code></td>
</tr><tr>
  <td><code>RETURN</code></td>
  <td><code>SHIFT</code></td>
  <td><code>NEWLINE</code></td>
</tr><tr>
  <td><code>ADD</code></td>
  <td><code>CTRL</code></td>
  <td><code>ZOOMIN</code></td>
</tr><tr>
  <td><code>SUBTRACT</code></td>
  <td><code>CTRL</code></td>
  <td><code>ZOOMOUT</code></td>
</tr><tr>
  <td><code>DIVIDE</code></td>
  <td><code>CTRL</code></td>
  <td><code>SETZOOM</code></td>
</tr><tr>
  <td><code>'A'</code></td>
  <td><code>CTRL</code></td>
  <td><code>SELECTALL</code></td>
</tr><tr>
  <td><code>'C'</code></td>
  <td><code>CTRL</code></td>
  <td><code>COPY</code></td>
</tr><tr>
  <td><code>'D'</code></td>
  <td><code>CTRL</code></td>
  <td><code>LINEDUPLICATE</code></td>
</tr><tr>
  <td><code>'L'</code></td>
  <td><code>CTRL</code></td>
  <td><code>LINECUT</code></td>
</tr><tr>
  <td><code>'L'</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>LINEDELETE</code></td>
</tr><tr>
  <td><code>'T'</code></td>
  <td><code>CTRL</code></td>
  <td><code>LINETRANSPOSE</code></td>
</tr><tr>
  <td><code>'T'</code></td>
  <td><code>CTRL+SHIFT</code></td>
  <td><code>LINECOPY</code></td>
</tr><tr>
  <td><code>'U'</code></td>
  <td><code>CTRL</code></td>
  <td><code>LOWERCASE</code></td>
</tr><tr>
  <td><code>'U'</code></td>
  <td><code>CTRL</code></td>
  <td><code>UPPERCASE</code></td>
</tr><tr>
  <td><code>'V'</code></td>
  <td><code>CTRL</code></td>
  <td><code>PASTE</code></td>
</tr><tr>
  <td><code>'X'</code></td>
  <td><code>CTRL</code></td>
  <td><code>CUT</code></td>
</tr><tr>
  <td><code>'Y'</code></td>
  <td><code>CTRL</code></td>
  <td><code>REDO</code></td>
</tr><tr>
  <td><code>'Z'</code></td>
  <td><code>CTRL</code></td>
  <td><code>UNDO</code></td>
</tr>
</tbody></table>
<p>
<b>Note:</b> The entries 'D', 'L', 'T', 'U' seldom fits anyones need, so simply remove them with <code>CmdKeyClear</code> if you don't need them.
</p>

<div class="divider2"></div>
<h4><a name="CmdKeyAssign">void CmdKeyAssign (int key, int modifiers, int cmd)</a></h4>
<p>
Assigns the given key definition to a Scintilla command identified by <code>cmd</code>. <code>cmd</code> can be any <code>wxSCI_...</code> command that has no arguments.
</p>

<div class="divider2"></div>
<h4><a name="CmdKeyClear">void CmdKeyClear (int key, int modifiers)</a></h4>
<p>
Makes the given key definition do nothing by assigning the action <code>wxSCI_SCMOD_NULL</code> to it.
</p>

<div class="divider2"></div>
<h4><a name="CmdKeyClearAll">void CmdKeyClearAll()</a></h4>
<p>
This command removes all keyboard command mapping by setting an empty mapping table.
</p>

<div class="divider1"></div>
<h3 id="PopupEditMenu">Popup edit menu</h3>

<div class="divider2"></div>
<h4><a name="UsePopUp">void UsePopUp (bool allowPopUp)</a></h4>
<p>
Clicking the right button on the mouse pops up a short default editing menu. This may be turned off with <code>UsePopUp (false)</code>. If you turn it off, context menu commands will not be handled by Scintilla, so the parent of the Scintilla window will have the opportunity to handle it.
</p>

<div class="divider1"></div>
<h3 id="MacroRecording">Macro recording</h3>

<p>
Start and stop macro recording mode. In macro recording mode, actions are reported to the container through <code><a class="message" href="#wxEVT_SCI_MACRORECORD">wxEVT_SCI_MACRORECORD</a></code> <a class="jump" href="#Notifications">notifications</a>. It is then up to the container to record these actions for future replay.
</p>

<div class="divider2"></div>
<h4><a name="StartRecord">void StartRecord()</a><br />
    <a name="StopRecord">void StopRecord()</a></h4>
<p>
Turn macro recording on and off.
</p>

<h3 id="Printing">Printing</h3>

<p>
On Windows <code>FormatRange</code> can be used to draw the text onto a display context which can include a printer display context. Printed output shows text styling as on the screen, but it hides all margins except a line number margin. All special marker effects are removed and the selection and caret are hidden.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#FormatRange">int FormatRange (bool doDraw, int startPos, int endPos, wxDC* draw, wxDC* target, wxRect renderRect, wxRect pageRect)</a></li>
<li><a class="message" href="#SetPrintMagnification">void SetPrintMagnification (int magnification)</a></li>
<li><a class="message" href="#GetPrintMagnification">int GetPrintMagnification()</a></li>
<li><a class="message" href="#SetPrintColourMode">void SetPrintColourMode (int mode)</a></li>
<li><a class="message" href="#GetPrintColourMode">int GetPrintColourMode()</a></li>
<li><a class="message" href="#SetPrintWrapMode">void SetPrintWrapMode (int mode)</a></li>
<li><a class="message" href="#GetPrintWrapMode">int GetPrintWrapMode()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="FormatRange">int FormatRange (bool doDraw, int startPos, int endPos, wxDC* draw, wxDC* target, wxRect renderRect, wxRect pageRect)</a></h4>
<p>
This call allows Windows users to render a range of text into a device context. If you use this for printing, you will probably want to arrange a page header and footer; Scintilla does not do this for you. Renders a range of text into a rectangular area and returns the position in the document of the next character to print.
</p>
<p>
<code>doDraw</code> controls if any output is done. Set this to false if you are paginating (for example, if you use this with MFC you will need to paginate in <code>OnBeginPrinting()</code> before you output each page.
</p>
<p>
<code>draw</code> and <code>target</code> should both be set to the device context handle of the output device (usually a printer). If you print to a metafile these will not be the same as Windows metafiles (unlike extended metafiles) do not implement the full API for returning information. In this case, set <code>hdcTarget</code> to the screen DC.<br />
<code>pageRect</code> is the rectangle <code>{0, 0, maxX, maxY}</code> where <code>maxX+1</code> and <code>maxY+1</code> are the number of physically printable pixels in x and y.<br />
<code>renderRect</code> is the rectangle to render the text in (which will, of course, fit within the rectangle defined by pageRect).<br />
<code>startPos</code> and <code>endPos</code> define the start position and maximum position of characters to output. All of each line within this character range is drawn.
</p>
<p>
When printing, the most tedious part is always working out what the margins should be to allow for the non-printable area of the paper and printing a header and footer. If you look at the printing code in SciTE, you will find that most of it is taken up with this. The loop that causes Scintilla to render text is quite simple if you strip out all the margin, non-printable area, header and footer code.
</p>

<div class="divider2"></div>
<h4><a name="SetPrintMagnification">void SetPrintMagnification (int magnification)</a><br />
    <a name="GetPrintMagnification">int GetPrintMagnification()</a></h4>
<p>
<code>GetPrintMagnification</code> lets you to print at a different size than the screen font. <code>magnification</code> is the number of points to add to the size of each screen font. A value of -3 or -4 gives reasonably small print. You can get this value with <code>GetPrintMagnification</code>.
</p>

<div class="divider2"></div>
<h4><a name="SetPrintColourMode">void SetPrintColourMode (int mode)</a><br />
    <a name="GetPrintColourMode">int GetPrintColourMode()</a></h4>
<p>
Set and get the method used to render coloured text on a printer that is probably using white paper. It is especially important to consider the treatment of colour if you use a dark or black screen background. Printing white on black uses up toner and ink very many times faster than the other way around. You can set the mode to one of:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Colour printing modes"><tbody>
<tr>
  <th align="left">Symbol</th>
  <th>Value</th>
  <th align="left">Purpose</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>wxSCI_PRINT_NORMAL</code></td>
  <td align="center">0</td>
  <td>Print using the current screen colours. This is the default.</td>
</tr><tr>
  <td align="left"><code>wxSCI_PRINT_INVERTLIGHT</code></td>
  <td align="center">1</td>
  <td>If you use a dark screen background this saves ink by inverting the light value of   all colours and printing on a white background.</td>
</tr><tr>
  <td align="left"><code>wxSCI_PRINT_BLACKONWHITE</code></td>
  <td align="center">2</td>
  <td>Print all text as black on a white background.</td>
</tr><tr>
  <td align="left"><code>wxSCI_PRINT_COLOURONWHITE</code></td>
  <td align="center">3</td>
  <td>Everything prints in its own colour on a white background.</td>
</tr><tr>
  <td align="left"><code>wxSCI_PRINT_COLOURONWHITEDEFAULTBG</code></td>
  <td align="center">4</td>
  <td>Everything prints in its own colour on a white background except that line numbers   use their own background colour.</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="SetPrintWrapMode">void SetPrintWrapMode (int mode)</a><br />
    <a name="GetPrintWrapMode">int GetPrintWrapMode()</a></h4>
<p>
These two functions get and set the printer wrap mode. <code>mode</code> can be  set to <code>wxSCI_WRAP_NONE</code> (0) or <code>wxSCI_WRAP_WORD</code> (1). The default is <code>wxSCI_WRAP_WORD</code>, which wraps printed output so that all characters fit into the print rectangle. If you set <code>wxSCI_WRAP_NONE</code>, each line of text generates one line of output and the line is truncated if it is too long to fit into the print area.
</p>

<div class="divider1"></div>
<h3 id="MultipleViews">Multiple views</h3>

<p>
A Scintilla window and the document that it displays are separate entities. When you create a new window, you also create a new, empty document. Each document has a reference count that is initially set to 1. The document also has a list of the Scintilla windows that are linked to it so when any window changes the document, all other windows in which it appears are notified to cause them to update. The system is arranged in this way so that you can work with many documents in a single Scintilla window and so you can display a single document in multiple windows (for use with splitter windows).
</p>
<p>
Although these use <code>document *pDoc</code>, to ensure compatibility with future releases of Scintilla you should treat <code>pDoc</code> as an opaque <code>void*</code>. That is, you can use and store the pointer as described in this section but you should not dereference it.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#GetDocPointer">void* GetDocPointer()</a></li>
<li><a class="message" href="#SetDocPointer">void SetDocPointer (void* docPointer)</a></li>
<li><a class="message" href="#CreateDocument">void* CreateDocument()</a></li>
<li><a class="message" href="#AddRefDocument">void AddRefDocument (void* docPointer)</a></li>
<li><a class="message" href="#ReleaseDocument">void ReleaseDocument (void* docPointer)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="GetDocPointer">void* GetDocPointer()</a></h4>
<p>
This returns a pointer to the document currently in use by the window. It has no other effect.
</p>

<div class="divider2"></div>
<h4><a name="SetDocPointer">void SetDocPointer (void* docPointer)</a></h4>
<p>
Does the following:<br />
1. It removes the current window from the list held by the current document.<br />
2. It reduces the reference count of the current document by 1.<br />
3. If the reference count reaches 0, the document is deleted.<br />
4. <code>pDoc</code> is set as the new document for the window.<br />
5. If <code>pDoc</code> was 0, a new, empty document is created and attached to the window.<br />
6. If <code>pDoc</code> was not 0, its reference count is increased by 1.
</p>

<div class="divider2"></div>
<h4><a name="CreateDocument">void* CreateDocument()</a></h4>
<p>
Creates a new, empty document and returns a pointer to it. This document is not selected into the editor and starts with a reference count of 1. This means that you have ownership of it and must either reduce its reference count by 1 after using <code>SetDocPointer</code> so that the Scintilla window owns it or you must make sure that you reduce the reference count by 1 with <code>ReleaseDocument</code> before you close the application to avoid memory leaks.
</p>

<div class="divider2"></div>
<h4><a name="AddRefDocument">void AddRefDocument (void* docPointer)</a></h4>
<p>
This increases the reference count of a document by 1. If you want to replace the current document in the Scintilla window and take ownership of the current document, for example if you are editing many documents in one window, do the following:<br />
1. Use <code>GetDocPointer()</code> to get a pointer to the document, <code>pDoc</code>.<br />
2. Use <code>AddRefDocument (pDoc)</code> to increment the reference count.<br />
3. Use <code>SetDocPointer (pNewDoc)</code> to set a different document or <code>SetDocPointer (0)</code> to set a new, empty document.
</p>

<div class="divider2"></div>
<h4><a name="ReleaseDocument">void ReleaseDocument (void* docPointer)</a></h4>
<p>
Reduces the reference count of the document identified by <code>pDoc</code>. pDoc must be the result of <code>GetDocPointer</code> or <code>CreateDocument</code> and must point at a document that still exists. If you call this on a document with a reference count of 1 that is still attached to a Scintilla window, bad things will happen. To keep the world spinning in its orbit you must balance each call to <code>CreateDocument</code> or <code>AddRefDocument</code> with a call to <code>ReleaseDocument</code>.
</p>

<div class="divider1"></div>
<h3 id="Folding">Folding</h3>

<p>
The fundamental operation in folding is making lines invisible or visible. Line visibility is a property of the view rather than the document so each view may be displaying a different set of lines. From the point of view of the user, lines are hidden and displayed using fold points. Generally, the fold points of a document are based on the hierarchical structure of the document contents. In Python, the hierarchy is determined by indentation and in C++ by brace characters. This hierarchy can be represented within a Scintilla document object by attaching a numeric "fold level" to each line. The fold level is most easily set by a lexer.
</p>
<p>
It is up to your code to set the connection between user actions and folding and unfolding. See the sample how they are used. You will also need to use markers and a folding margin to complete your folding implementation. The <code>"fold"</code> property should be set to <code>"1"</code> with <code>SetProperty("fold", "1")</code> to enable folding.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#VisibleFromDocLine">int VisibleFromDocLine (int line)</a></li>
<li><a class="message" href="#DocLineFromVisible">int DocLineFromVisible (int lineDisplay)</a></li>
<li><a class="message" href="#ShowLines">void ShowLines (int lineStart, int lineEnd)</a></li>
<li><a class="message" href="#HideLines">void HideLines (int lineStart, int lineEnd)</a></li>
<li><a class="message" href="#GetLineVisible">bool GetLineVisible (int line)</a></li>
<li><a class="message" href="#SetFoldLevel">void SetFoldLevel (int line, int level)</a></li>
<li><a class="message" href="#GetFoldLevel">int GetFoldLevel (int line)</a></li>
<li><a class="message" href="#SetFoldFlags">void SetFoldFlags (int flags)</a></li>
<li><a class="message" href="#GetLastChild">int GetLastChild (int line, int level)</a></li>
<li><a class="message" href="#GetFoldParent">int GetFoldParent (int line)</a></li>
<li><a class="message" href="#SetFoldExpanded">void SetFoldExpanded (int line, bool expanded)</a></li>
<li><a class="message" href="#GetFoldExpanded">bool GetFoldExpanded (int line)</a></li>
<li><a class="message" href="#ToggleFold">void ToggleFold (int line)</a></li>
<li><a class="message" href="#EnsureVisible">void EnsureVisible (int line)</a></li>
<li><a class="message" href="#EnsureVisibleEnforcePolicy">void EnsureVisibleEnforcePolicy (int line)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="VisibleFromDocLine">int VisibleFromDocLine (int line)</a></h4>
<p>
When some lines are folded, then a particular line in the document may be displayed at a different position to its document position. If no lines are folded, it returns <code>docLine</code>. Otherwise, this returns the display line (counting the very first visible line as 0). The display line of an invisible line is the same as the previous visible line. The display line number of the first line in the document is 0. If there is folding and <code>docLine</code> is outside the range of lines in the document, the return value is -1. Lines can occupy more than one display line if they wrap.
</p>

<div class="divider2"></div>
<h4><a name="DocLineFromVisible">int DocLineFromVisible (int lineDisplay)</a></h4>
<p>
When some lines are hidden, then a particular line in the document may be displayed at a different position to its document position. Returns the document line number that corresponds to a display line (counting the display line of the first line in the document as 0). If <code>displayLine</code> is less than or equal to 0, the result is 0. If <code>displayLine</code> is greater than or equal to the number of displayed lines, the result is the number of lines in the document.
</p>

<div class="divider2"></div>
<h4><a name="ShowLines">void ShowLines (int lineStart, int lineEnd)</a><br />
    <a name="HideLines">void HideLines (int lineStart, int lineEnd)</a><br />
    <a name="GetLineVisible">bool GetLineVisible (int line)</a></h4>
<p>
The first two mark a range of lines as visible or invisible and then redraw the display. The third reports on the visible state of a line and returns true if it is visible, otherwise false. These have no effect on fold levels or fold flags.
</p>

<div class="divider2"></div>
<h4><a name="SetFoldLevel">void SetFoldLevel (int line, int level)</a><br />
    <a name="GetFoldLevel">int GetFoldLevel (int line)</a></h4>
<p>
Set and get a 32-bit value that contains the fold level of a line and some flags associated with folding. The fold level is a number in the range 0 to <code>wxSCI_FOLDLEVELNUMBERMASK</code> (4095). However, the initial fold level is set to <code>wxSCI_FOLDLEVELBASE</code> (1024) to allow unsigned arithmetic on folding levels. There are two addition flag bits. <code>wxSCI_FOLDLEVELWHITEFLAG</code> indicates that the line is blank and allows it to be treated slightly different then its level may indicate. For example, blank lines should generally not be fold points and will be considered part of the preceding section even though they may have a lesser fold level. <code>wxSCI_FOLDLEVELHEADERFLAG</code> indicates that the line is a header (fold point).
</p>
<p>
Use <code>GetFoldLevel(line) &amp; wxSCI_FOLDLEVELNUMBERMASK</code> to get the fold level of a line. Likewise, use <code>GetFoldLevel(line) &amp; wxSCI_FOLDLEVEL*FLAG</code> to get the state of the flags. To set the fold level you must or in the associated flags. For instance, to set the level to <code>thisLevel</code> and mark a line as being a fold point use: <code>SetFoldLevel(line, thisLevel | wxSCI_FOLDLEVELHEADERFLAG)</code>.
</p>
<p>
If you use a lexer, you should not need to use <code>SetFoldLevel</code> as this is far better handled by the lexer. You will need to use <code>GetFoldLevel</code> to decide how to handle user folding requests. If you do change the fold levels, the folding margin will update to match your changes.
</p>

<div class="divider2"></div>
<h4><a name="SetFoldFlags">void SetFoldFlags (int flags)</a></h4>
<p>
In addition to showing markers in the folding margin, you can indicate folds to the user by drawing lines in the text area. The lines are drawn in the foreground colour set for <a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_DEFAULT</code></a>. Bits set in <code>flags</code> determine where folding lines are drawn:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Fold flags"><thead>
<tr>
  <th align="center">Value</th>
  <th align="left">Effect</th>
</tr>
</thead><tbody valign="top">
<tr>
  <td align="center">1</td>
  <td align="left">Experimental - draw boxes if expanded</td>
</tr><tr>
  <td align="center">2</td>
  <td align="left">Draw above if expanded</td>
</tr><tr>
  <td align="center">4</td>
  <td align="left">Draw above if not expanded</td>
</tr><tr>
  <td align="center">8</td>
  <td align="left">Draw below if expanded</td>
</tr><tr>
  <td align="center">16</td>
  <td align="left">Draw below if not expanded</td>
</tr><tr>
  <td align="center">64</td>
  <td align="left">display hexadecimal fold levels in line margin to aid debugging of   folding. This feature needs to be redesigned to be sensible.</td>
</tr>
</tbody></table>
<p>
Causes the display to redraw.
</p>

<div class="divider2"></div>
<h4><a name="GetLastChild">int GetLastChild (int line, int level)</a></h4>
<p>
Searches for the next line after <code>line</code>, that has a folding level that is less than or equal to <code>level</code> and then returns the previous line number. If you set <code>level</code> to -1, <code>level</code> is set to the folding level of line <code>line</code>. If <code>line</code> is a fold point, <code>GetLastChild(from, -1)</code> returns the last line that would be in made visible or hidden by toggling the fold state.
</p>

<div class="divider2"></div>
<h4><a name="GetFoldParent">int GetFoldParent (int line)</a></h4>
<p>
Returns the line number of the first line before <code>line</code> that is marked as a fold point with <code>wxSCI_FOLDLEVELHEADERFLAG</code> and has a fold level less than the <code>line</code>. If no line is found, or if the header flags and fold levels are inconsistent, the return value is -1.
</p>

<div class="divider2"></div>
<h4><a name="ToggleFold">void ToggleFold (int line)</a></h4>
<p>
Each fold point may be either expanded, displaying all its child lines, or contracted, hiding all the child lines. Toggles the folding state of the given line as long as it has the <code>wxSCI_FOLDLEVELHEADERFLAG</code> set. Takes care of folding or expanding all the lines that depend on the line. The display updates afterwards.
</p>

<div class="divider2"></div>
<h4><a name="SetFoldExpanded">void SetFoldExpanded (int line, bool expanded)</a><br />
    <a name="GetFoldExpanded">bool GetFoldExpanded (int line)</a></h4>
<p>
Set and get the expanded state of a single line. The set has no effect on the visible state of the line or any lines that depend on it. It does change the markers in the folding margin. If you ask for the expansion state of a line that is outside the document, the result is <code>false</code>.
</p>
<p>
If you just want to toggle the fold state of one line and handle all the lines that are dependent on it, it is much easier to use <code>ToggleFold</code>. You would use the <code>SetFoldExpanded</code> to process many folds without updating the display until you had finished.
</p>

<div class="divider2"></div>
<h4><a name="EnsureVisible">EnsureVisible(int line)</a><br />
    <a name="EnsureVisibleEnforcePolicy">void EnsureVisibleEnforcePolicy (int line)</a></h4>
<p>
A line may be hidden because more than one of its parent lines is contracted. Both travels up the fold hierarchy, expanding any contracted folds until they reach the top level. The line will then be visible. If you use <code>EnsureVisibleEnforcePolicy</code>, the vertical caret policy set by <a class="message" href="#SetVisiblePolicy"><code>SetVisiblePolicy</code></a> is then applied.
</p>

<div class="divider1"></div>
<h3 id="LineWrapping">Line wrapping</h3>

<ul style="list-style-type:none">
<li><a class="message" href="#SetWrapMode">void SetWrapMode (int mode)</a></li>
<li><a class="message" href="#GetWrapMode">int GetWrapMode()</a></li>
<li><a class="message" href="#SetWrapVisualFlags">void SetWrapVisualFlags (int wrapVisualFlags)</a></li>
<li><a class="message" href="#GetWrapVisualFlags">int GetWrapVisualFlags()</a></li>
<li><a class="message" href="#SetWrapVisualFlagsLocation">void SetWrapVisualFlagsLocation (int wrapVisualFlagsLocation)</a></li>
<li><a class="message" href="#GetWrapVisualFlagsLocation">int GetWrapVisualFlagsLocation()</a></li>
<li><a class="message" href="#SetWrapStartIndent">void SetWrapStartIndent (int indent)</a></li>
<li><a class="message" href="#GetWrapStartIndent">int GetWrapStartIndent()</a></li>
<li><a class="message" href="#SetLayoutCache">void SetLayoutCache (int mode)</a></li>
<li><a class="message" href="#GetLayoutCache">int GetLayoutCache()</a></li>
<li><a class="message" href="#LinesSplit">void LinesSplit (int pixels)</a></li>
<li><a class="message" href="#LinesJoin">void LinesJoin()</a></li>
<li><a class="message" href="#WrapCount">int WrapCount (int line)</a></li>
</ul>

<p>
By default, Scintilla does not wrap lines of text. If you enable line wrapping, lines wider than the window width are continued on the following lines. Lines are broken after space or TAB characters or between runs of different styles. If this is not possible because a word in one style is wider than the window then the break occurs after the last character that completely fits on the line. The horizontal scroll bar does not appear when wrap mode is on.
</p>
<p>
For wrapped lines Scintilla can draw visual flags (little arrows) at end of a a subline of a wrapped line and at begin of the next subline. These can be enabled individually, but if Scintilla draws the visual flag at begin of the next subline this subline will be indented by one char. Independent from drawing a visual flag at the begin the subline can have an indention.
</p>
<p>
Much of the time used by Scintilla is spent on laying out and drawing text. The same text layout calculations may be performed many times even when the data used in these calculations does not change. To avoid these unnecessary calculations in some circumstances, the line layout cache can store the results of the calculations. The cache is invalidated whenever the underlying data, such as the contents or styling of the document changes. Caching the layout of the whole document has the most effect, making dynamic line wrap as much as 20 times faster but this requires 7 times the memory required by the document contents plus around 80 bytes per line.
</p>
<p>
Wrapping is not performed immediately there is a change but is delayed until the display is redrawn. This delay improves peformance by allowing a set of changes to be performed and then wrapped and displayed once. Because of this, some operations may not occur as expected. If a file is read and the scroll position moved to a particular line in the text, such as occurs when a container tries to restore a previous editing session, then the scroll position will have been determined before wrapping so an unexpected range of text will be displayed. To scroll to the position correctly, delay the scroll until the wrapping has been performed by waiting for an initial <a class="message" href="#wxEVT_SCI_PAINTED">wxEVT_SCI_PAINTED</a> notification.
</p>

<div class="divider2"></div>
<h4><a name="SetWrapMode">void SetWrapMode (int mode)</a><br />
    <a name="GetWrapMode">int GetWrapMode()</a></h4>
<p>
Set wrapMode to <code>wxSCI_WRAP_WORD</code> (1) to enable line wrapping and to <code>wxSCI_WRAP_NONE</code> to disable line wrapping.
</p>

<div class="divider2"></div>
<h4><a name="SetWrapVisualFlags">void SetWrapVisualFlags (int wrapVisualFlags)</a><br />
    <a name="GetWrapVisualFlags">int GetWrapVisualFlags()</a></h4>
<p>
You can enable the drawing of visual flags to indicate a line is wrapped. Bits set in wrapVisualFlags determine which visual flags are drawn.
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Wrap visual flags"><tbody>
<tr>
  <th align="left">Symbol</th>
  <th>Value</th>
  <th align="left">Effect</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>wxSCI_WRAPVISUALFLAG_NONE</code></td>
  <td align="center">0</td>
  <td>No visual flags</td>
</tr><tr>
  <td align="left"><code>wxSCI_WRAPVISUALFLAG_END</code></td>
  <td align="center">1</td>
  <td>Visual flag at end of subline of a wrapped line.</td>
</tr><tr>
  <td align="left"><code>wxSCI_WRAPVISUALFLAG_START</code></td>
  <td align="center">2</td>
  <td>Visual flag at begin of subline of a wrapped line. Subline is indented by at least 1 to make room for the flag.</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="SetWrapVisualFlagsLocation">SetWrapVisualFlagsLocation(int wrapVisualFlagsLocation)</a><br />
    <a name="GetWrapVisualFlagsLocation">int GetWrapVisualFlagsLocation()</a></h4>
<p>
You can set wether the visual flags to indicate a line is wrapped are drawn near the border or near the text. Bits set in wrapVisualFlagsLocation set the location to near the text for the corresponding visual flag.
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Wrap visual flags locations">  <tbody>
<tr>
  <th align="left">Symbol</th>
  <th>Value</th>
  <th align="left">Effect</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>wxSCI_WRAPVISUALFLAGLOC_DEFAULT</code></td>
  <td align="center">0</td>
  <td>Visual flags drawn near border</td>
</tr><tr>
  <td align="left"><code>wxSCI_WRAPVISUALFLAGLOC_END_BY_TEXT</code></td>
  <td align="center">1</td>
  <td>Visual flag at end of subline drawn near text</td>
</tr><tr>
  <td align="left"><code>wxSCI_WRAPVISUALFLAGLOC_START_BY_TEXT</code></td>
  <td align="center">2</td>
  <td>Visual flag at begin of subline drawn near text</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="SetWrapStartIndent">void SetWrapStartIndent (int indent)</a><br />
    <a name="GetWrapStartIndent">int GetWrapStartIndent()</a></h4>
<p>
<code>SetWrapStartIndent</code> sets the size of indentation of sublines for wrapped lines in terms of the width of a space in <a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_DEFAULT</code></a>. There are no limits on indent sizes, but values less than 0 or large values may have undesirable effects. The indention of sublines is in dependent of visual flags, but if <code>wxSCI_WRAPVISUALFLAG_START</code> is set an indent of at least 1 is used.
</p>

<div class="divider2"></div>
<h4><a name="SetLayoutCache">void SetLayoutCache (int mode)</a><br />
    <a name="GetLayoutCache">int GetLayoutCache()</a></h4>
<p>
You can set <code>cacheMode</code> to one of the symbols in the table:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Line caching styles"><tbody>
<tr>
  <th align="left">Symbol</th>
  <th>Value</th>
  <th align="left">Layout cached for these lines</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>SC_CACHE_NONE</code></td>
  <td align="center">0</td>
  <td>No lines are cached.</td>
</tr><tr>
  <td align="left"><code>SC_CACHE_CARET</code></td>
  <td align="center">1</td>
  <td>The line containing the text caret. This is the default.</td>
</tr><tr>
  <td align="left"><code>SC_CACHE_PAGE</code></td>
  <td align="center">2</td>
  <td>Visible lines plus the line containing the caret.</td>
</tr><tr>
  <td align="left"><code>SC_CACHE_DOCUMENT</code></td>
  <td align="center">3</td>
  <td>All lines in the document.</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="LinesSplit">void LinesSplit (int pixels)</a></h4>
<p>
Split a range of lines indicated by the target into lines that are at most pixels wide. Splitting occurs on word boundaries wherever possible in a similar manner to line wrapping. When <code>pixels</code> is 0 then the width of the window is used.
</p>

<div class="divider2"></div>
<h4><a name="LinesJoin">void LinesJoin()</a></h4>
<p>
Join a range of lines indicated by the target into one line by removing line end characters. Where this would lead to no space between words, an extra space is inserted.
</p>

<div class="divider2"></div>
<h4><a name="WrapCount">int WrapCount (int line)</a></h4>
<p>
Document lines can occupy more than one display line if they wrap and this returns the number of display lines needed to wrap a document line.
</p>

<div class="divider1"></div>
<h3 id="Zooming">Zooming</h3>

<p>
Scintilla incorporates a "zoom factor" that lets you make all the text in the document larger or smaller in steps of one point. The displayed point size never goes below 2, whatever zoom factor you set. You can set zoom factors in the range -10 to +20 points.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#ZoomIn">void ZoomIn()</a></li>
<li><a class="message" href="#ZoomOut">void ZoomOut()</a></li>
<li><a class="message" href="#SetZoom">void SetZoom (int zoom)</a></li>
<li><a class="message" href="#GetZoom">int GetZoom()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="ZoomIn">void ZoomIn()</a><br />
    <a name="ZoomOut">void ZoomOut()</a></h4>
<p>
<code>ZoomIn</code> increases the zoom factor by one point if the current zoom factor is less than 20 points. <code>ZoomOut</code> decreases the zoom factor by one point if the current zoom factor is greater than -10 points.
</p>

<div class="divider2"></div>
<h4><a name="SetZoom">void SetZoom (int zoom)</a><br />
    <a name="GetZoom">int GetZoom()</a></h4>
<p>
Set and get the zoom factor directly. There is no limit set on the factors you can set, so limiting yourself to -10 to +20 to match the incremental zoom functions is a good idea.
</p>

<div class="divider1"></div>
<h3 id="LongLines">Long lines</h3>

<p>
You can choose to mark lines that exceed a given length by drawing a vertical line or by colouring the background of characters that exceed the set length.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#SetEdgeMode">void SetEdgeMode (int mode)</a></li>
<li><a class="message" href="#GetEdgeMode">int GetEdgeMode()</a></li>
<li><a class="message" href="#SetEdgeColumn">void SetEdgeColumn (int column)</a></li>
<li><a class="message" href="#GetEdgeColumn">int GetEdgeColumn()</a></li>
<li><a class="message" href="#SetEdgeColour">void SetEdgeColour (const wxColour& colour)</a></li>
<li><a class="message" href="#GetEdgeColour">wxColour GetEdgeColour()</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetEdgeMode">void SetEdgeMode (int mode)</a><br />
    <a name="GetEdgeMode">int GetEdgeMode()</a></h4>
<p>
Set and get the mode used to display long lines. You can set one of the values in the table:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Long line styles"><tbody>
<tr>
  <th align="left">Symbol</th>
  <th>Value</th>
  <th align="left">Long line display mode</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>wxSCI_EDGE_NONE</code></td>
  <td align="center">0</td>
  <td>Long lines are not marked. This is the default state.</td>
</tr><tr>
  <td align="left"><code>wxSCI_EDGE_LINE</code></td>
  <td align="center">1</td>
  <td>A vertical line is drawn at the column number set by <code>SetEdgeColumn</code>.   This works well for monospaced fonts. The line is drawn at a position based on the width
  of a space character in <a class="message" href="#StyleDefinition"><code>wxSCI_STYLE_DEFAULT</code></a>, so it may not work very well if your styles use proportional fonts or if your style have varied font sizes or you use a mixture of bold, italic and normal text.</td>
</tr><tr>
  <td align="left"><code>wxSCI_EDGE_BACKGROUND</code></td>
  <td align="center">2</td>
  <td>The background colour of characters after the column limit is changed to the colour   set by <code>SetEdgeColour</code>. This is recommended for proportional fonts.</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="SetEdgeColumn">void SetEdgeColumn (int column)</a><br />
    <a name="GetEdgeColumn">int GetEdgeColumn()</a></h4>
<p>
Set and get the column number at which to display the long line marker. When drawing lines, the column sets a position in units of the width of a space character in <code>wxSCI_STYLE_DEFAULT</code>. When setting the background colour, the column is a character count (allowing for tabs) into the line.
</p>

<div class="divider2"></div>
<h4><a name="SetEdgeColour">void SetEdgeColour (const wxColour& colour)</a><br/>
    <a name="GetEdgeColour">wxColour GetEdgeColour()</a></h4>
<p>
Set and get the colour of the marker used to show that a line has exceeded the length set by <code>SetEdgeColumn</code>.
</p>

<div class="divider1"></div>
<h3 id="Lexer">Lexer</h3>

<p>
If you define the symbol <code>SCI_LEXER</code> when building Scintilla, (this is sometimes called the SciLexer version of Scintilla), lexing support for a wide range programming languages is included. If you want to set styling and fold points for an unsupported language you can either do this in the container or better still, write your own lexer following the pattern of one of the existing ones.
</p>
<p>
Scintilla also supports external lexers. These are DLLs (on Windows) or .so modules (on GTK+/Linux) that export four functions: <code>GetLexerCount</code>, <code>GetLexerName</code>, <code>Lex</code> and <code>Fold</code>. See <code>externalLexer.cxx</code> for more.
</p>

<ul style="list-style-type:none">
<li><a class="message" href="#SetLexer">void SetLexer (int lexer)</a></li>
<li><a class="message" href="#GetLexer">int GetLexer()</a></li>
<li><a class="message" href="#SetLexerLanguage">void SetLexerLanguage (const wxString& language)</a></li>
<li><a class="message" href="#LoadLexerLibrary">LoadLexerLibrary: Currently not implemented!</a></li>
<li><a class="message" href="#Colourise">void Colourise (int start, int end)</a></li>
<li><a class="message" href="#SetProperty">void SetProperty (const wxString& key, const wxString& value)</a></li>
<li><a class="message" href="#GetProperty">void GetProperty (const wxString& key, wxString& value)</a></li>
<li><a class="message" href="#GetPropertyExpanded">void GetPropertyExpanded (const wxString& key, wxString& value)</a></li>
<li><a class="message" href="#GetProperty">int GetPropertyInt (const wxString& key)</a></li>
<li><a class="message" href="#SetKeyWords">void SetKeyWords (int keywordSet, const wxString& keyWords)</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="SetLexer">void SetLexer (int lexer)</a><br />
    <a name="GetLexer">int GetLexer()</a></h4>
<p>
You can select the lexer to use with an integer code from the <code>wxSCI_LEX_*</code> enumeration in <code>Scintilla.h</code>. There are two codes in this sequence that do not use lexers:<br />
<code>wxSCI_LEX_NULL</code> to select no lexing action and <code>wxSCI_LEX_CONTAINER</code> which sends the <code><a class="message" href="#wxEVT_SCI_STYLENEEDED">wxEVT_SCI_STYLENEEDED</a></code> notification to the container whenever a range of text needs to be styled. You cannot use the <code>wxSCI_LEX_AUTOMATIC</code> value; this identifies additional external lexers that Scintilla assigns unused lexer numbers to.
</p>

<div class="divider2"></div>
<h4><a name="SetLexerLanguage">void SetLexerLanguage (const wxString& language)</a></h4>
<p>
Lets you select a lexer by name, and is the only method if you are using an external lexer or if you have written a lexer module for a language of your own and do not wish to assign it an explicit lexer number. To select an existing lexer, set <code>name</code> to match the (case sensitive) name given to the module, for example "ada" or "python", not "Ada" or "Python". To locate the name for the built-in lexers, open the relevant <code>Lex*.cxx</code> file and search for <code>LexerModule</code>. The third argument in the <code>LexerModule</code> constructor is the name to use.
</p>
<p>
To test if your lexer assignment worked, use <a class="message" href="#GetLexer"><code>GetLexer</code></a> before and after setting the new lexer to see if the lexer number changed.
</p>

<div class="divider2"></div>
<h4><a name="Colourise">void Colourise (int startPos, int endPos)</a></h4>
<p>
This forces the current lexer or the container (if the lexer is set to <code>wxSCI_LEX_CONTAINER</code>) to style the document between <code>startPos</code> and <code>endPos</code>. If <code>endPos</code> is wxSCI_INVALID_POSITION, the document is styled from <code>startPos</code> to the end. If the <code>"fold"</code> property is set to <code>"1"</code> and your lexer or container supports folding, fold levels are also set. Causes a redraw.
</p>

<div class="divider2"></div>
<h4><a name="SetProperty">void SetProperty (const wxString& key, const wxString& value)</a></h4>
<p>
You can communicate settings to lexers with keyword:value string pairs. There is no limit to the number of keyword pairs you can set, other than available memory. <code>key</code> is a case sensitive keyword, <code>value</code> is a string that is associated with the keyword. If there is already a value string associated with the keyword, it is replaced. If you pass a zero length string, nothing is done. Both <code>key</code> and <code>value</code> are used without modification; extra spaces at the beginning or end of <code>key</code> are significant.
</p>
<p>The <code>value</code> string can refer to other keywords. For example, <code>SetProperty ("foldTimes10", "$(fold)0")</code> stores the string <code>"$(fold)0"</code>, but when this is accessed, the <code>$(fold)</code> is replaced by the value of the <code>"fold"</code> keyword (or by nothing if this keyword does not exist).
</p>
<p>
Currently the "fold" property is defined for most of the lexers to set the fold structure if set to "1". <code>wxSCI_LEX_PYTHON</code> understands <code>"TAB.timmy.whinge.level"</code> as a setting that determines how to indicate bad indentation. Most keywords have values that are interpreted as integers. Search the lexer sources for <code>GetPropertyInt</code> to see how properties are used.
</p>

<div class="divider2"></div>
<h4><a name="GetProperty">void GetProperty (const wxString& key, wxString& value)</a></h4>
<p>
Lookup a keyword:value pair using the specified key; if found, copy the value to the user-supplied buffer and return the length (not including the terminating 0).  If not found, copy an empty string to the buffer and return 0.
</p>
<p>
Note that  "keyword replacement" as described in <a class="message" href="#SetProperty"><code>SetProperty</code></a> will not be performed.
</p>
<p>
If the value argument is 0 then the length that should be allocated to store the value is returned; again, the terminating 0 is not included.
</p>

<div class="divider2"></div>
<h4><a name="GetPropertyExpanded">void GetPropertyExpanded (const wxString& key, wxString& value)</a></h4>
<p>
Lookup a keyword:value pair using the specified key; if found, copy the value to the user-supplied buffer and return the length (not including the terminating 0). If not found, copy an empty string to the buffer and return 0.
</p>
<p>
Note that  "keyword replacement" as described in <a class="message" href="#SetProperty"><code>SetProperty</code></a> will not be performed.
</p>
<p>
If the value argument is 0 then the length that should be allocated to store the value (including any indicated keyword replacement) is returned; again, the terminating 0 is not included.
</p>

<div class="divider2"></div>
<h4><a name="GetPropertyInt">int GetPropertyInt (const wxString& key)</a></h4>
<p>
Lookup a keyword:value pair using the specified key; if found, interpret the value as an integer and return it. If not found (or the value is not a number) then return 0.
</p>
<p>
Note that  "keyword replacement" as described in <a class="message" href="#SetProperty"><code>SetProperty</code></a> will not be performed.
</p>

<div class="divider2"></div>
<h4><a name="SetKeyWords">void SetKeyWords (int keywordSet, const wxString& keyWords)</a></h4>
<p>
You can set up to 9 lists of keywords for use by the current lexer. <code>keyWordSet</code> can be 0 to 8 (actually 0 to <code>wxSCI_KEYWORDSET_MAX</code>) and selects which keyword list to replace. <code>keyWordList</code> is a list of keywords separated by spaces, tabs, <code>"\n"</code> or <code>"\r"</code> or any combination of these. It is expected that the keywords will be composed of standard ASCII printing characters, but there is nothing to stop you using any non-separator character codes from 1 to 255 (except common sense).
</p>
<p>
How these keywords are used is entirely up to the lexer. Some languages, such as HTML may contain embedded languages, VBScript and JavaScript are common for HTML. For HTML, key word set 0 is for HTML, 1 is for JavaScript and 2 is for VBScript, 3 is for Python, 4 is for PHP and 5 is for SGML and DTD keywords. Review the lexer code to see examples of keyword list. A fully conforming lexer sets the fourth argument of the <code>LexerModule</code> constructor to be a list of strings that describe the uses of the keyword lists.
</p>
<p>
Alternatively, you might use set 0 for general keywords, set 1 for keywords that cause indentation and set 2 for keywords that cause unindentation. Yet again, you might have a simple lexer that colours keywords and you could change languages by changing the keywords in set 0. There is nothing to stop you building your own keyword lists into the lexer, but this means that the lexer must be rebuilt if more keywords are added.
</p>

<div class="divider1"></div>
<h3 id="Notifications">Notifications</h3>

<p>
Notifications are sent (fired) from the Scintilla control to its container when an event has occurred that may interest the container. Notifications are sent using the <code>WM_NOTIFY</code> message on Windows and the "notify" signal on GTK+.
</p>
<p>
The notification messages that your container can choose to handle and the messages associated with them are:
</p>
<ul style="list-style-type:none">
<li><a class="message" href="#wxEVT_SCI_CHANGE">wxEVT_SCI_CHANGE</a></li>
<li><a class="message" href="#wxEVT_SCI_STYLENEEDED">wxEVT_SCI_STYLENEEDED</a></li>
<li><a class="message" href="#wxEVT_SCI_CHARADDED">wxEVT_SCI_CHARADDED</a></li>
<li><a class="message" href="#wxEVT_SCI_SAVEPOINTREACHED">wxEVT_SCI_SAVEPOINTREACHED</a></li>
<li><a class="message" href="#wxEVT_SCI_SAVEPOINTLEFT">wxEVT_SCI_SAVEPOINTLEFT</a></li>
<li><a class="message" href="#wxEVT_SCI_MODIFYATTEMPTRO">wxEVT_SCI_MODIFYATTEMPTRO</a></li>
<li><a class="message" href="#wxEVT_SCI_KEY">wxEVT_SCI_KEY</a></li>
<li><a class="message" href="#wxEVT_SCI_DOUBLECLICK">wxEVT_SCI_DOUBLECLICK</a></li>
<li><a class="message" href="#wxEVT_SCI_UPDATEUI">wxEVT_SCI_UPDATEUI</a></li>
<li><a class="message" href="#wxEVT_SCI_MODIFIED">wxEVT_SCI_MODIFIED</a></li>
<li><a class="message" href="#wxEVT_SCI_MACRORECORD">wxEVT_SCI_MACRORECORD</a></li>
<li><a class="message" href="#wxEVT_SCI_MARGINCLICK">wxEVT_SCI_MARGINCLICK</a></li>
<li><a class="message" href="#wxEVT_SCI_NEEDSHOWN">wxEVT_SCI_NEEDSHOWN</a></li>
<li><a class="message" href="#wxEVT_SCI_PAINTED">wxEVT_SCI_PAINTED</a></li>
<li><a class="message" href="#wxEVT_SCI_USERLISTSELECTION">wxEVT_SCI_USERLISTSELECTION</a></li>
<li><a class="message" href="#wxEVT_SCI_URIDROPPED">wxEVT_SCI_URIDROPPED</a></li>
<li><a class="message" href="#wxEVT_SCI_DWELLSTART">wxEVT_SCI_DWELLSTART</a></li>
<li><a class="message" href="#wxEVT_SCI_DWELLEND">wxEVT_SCI_DWELLEND</a></li>
<li><a class="message" href="#wxEVT_SCI_ZOOM">wxEVT_SCI_ZOOM</a></li>
<li><a class="message" href="#wxEVT_SCI_HOTSPOT_CLICK">wxEVT_SCI_HOTSPOT_CLICK</a></li>
<li><a class="message" href="#wxEVT_SCI_HOTSPOT_DCLICK">wxEVT_SCI_HOTSPOT_DCLICK</a></li>
<li><a class="message" href="#wxEVT_SCI_CALLTIP_CLICK">wxEVT_SCI_CALLTIP_CLICK</a></li>
<li><a class="message" href="#wxEVT_SCI_AUTOCOMP_SELECTION">wxEVT_SCI_AUTOCOMP_SELECTION</a></li>
</ul>

<p>
The following functions are associated with these notifications:
</p>
<ul style="list-style-type:none">
<li><a class="message" href="#SetModEventMask">void SetModEventMask (int mask)</a></li>
<li><a class="message" href="#GetModEventMask">int GetModEventMask()</a></li>
<li><a class="message" href="#SetMouseDwellTime">void SetMouseDwellTime (int periodMilliseconds)</a></li>
<li><a class="message" href="#GetMouseDwellTime">int GetMouseDwellTime()</a></li>
</ul>

<a name="wxEVT_SCI_CHANGE">wxEVT_SCI_CHANGE</a>
<p>
The following additional notifications are sent using the <code>WM_COMMAND</code> message on Windows and the "Command" signal on GTK+ to emulate the Windows Edit control:
</p>
<ul style="list-style-type:none">
<li><a class="message" href="#wxEVT_SCI_CHANGE">wxEVT_SCI_CHANGE</a></li>
</ul>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_STYLENEEDED">wxEVT_SCI_STYLENEEDED</a></h4>
<p>
If you used <code><a class="message" href="#SetLexer">SetLexer</a>(wxSCI_LEX_CONTAINER)</code> to make the container act as the lexer, you will receive this notification when Scintilla is about to display or print text that requires styling. You are required to style the text from the line that contains the position returned by <a class="message" href="#GetEndStyled"><code>GetEndStyled</code></a> up to the position passed in <code>SCNotification.position</code>. Symbolically, you need code of the form:
</p>
<pre>
  startPos = <a class="message" href="#GetEndStyled">GetEndStyled</a>()
  lineNumber = <a class="message" href="#LineFromPosition">LineFromPosition</a>(startPos);
  startPos = <a class="message" href="#PositionFromLine">PositionFromLine</a>(lineNumber);
  MyStyleRoutine(startPos, SCNotification.position);
</pre>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_CHARADDED">wxEVT_SCI_CHARADDED</a></h4>
<p>
This is sent when the user types an ordinary text character (as opposed to a command character) that is entered into the text. The container can use this to decide to display a <a class="jump" href="#CallTips">call tip</a> or an <a class="jump" href="#Autocompletion">auto completion list</a>. The character is in <code>SCNotification.ch</code>. This notification is sent before the character has been styled so processing that depends on            styling should instead be performed in the <a class="message" href="#wxEVT_SCI_UPDATEUI"><code>wxEVT_SCI_UPDATEUI</code></a> notification.

</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_SAVEPOINTREACHED">wxEVT_SCI_SAVEPOINTREACHED</a><br />
    <a name="wxEVT_SCI_SAVEPOINTLEFT">wxEVT_SCI_SAVEPOINTLEFT</a></h4>
<p>
Sent to the container when the save point is entered or left, allowing the container to display a "document dirty" indicator and change its menus.
</p>
<p>
See also: <code><a class="message" href="#SetSavePoint">SetSavePoint</a>, <a class="message" href="#GetModify"><code>GetModify</code></a>
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_MODIFYATTEMPTRO">wxEVT_SCI_MODIFYATTEMPTRO</a></h4>
<p>
When in read-only mode, this notification is sent to the container if the user tries to change the text. This can be used to check the document out of a version control system. You can set the read-only state of a document with <code><a class="message" href="#SetReadOnly">SetReadOnly</a></code>.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_KEY">wxEVT_SCI_KEY</a></h4>
<p>
Reports all keys pressed. Used on GTK+ because of some problems with keyboard focus and is not sent by the Windows version. <code>SCNotification.ch</code> holds the key code and
<code>SCNotification.modifiers</code> holds the modifiers. This notification is sent if the modifiers include <code>SCMOD_ALT</code> or <code>SCMOD_CTRL</code> and the key code is less than 256.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_DOUBLECLICK">wxEVT_SCI_DOUBLECLICK</a></h4>
<p>
The mouse button was double clicked in editor. There is no additional information.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_UPDATEUI">wxEVT_SCI_UPDATEUI</a></h4>
<p>
Either the text or styling of the document has changed or the selection range has changed. Now would be a good time to update any container UI elements that depend on document or view state. This was previously called <code><a class="message" href="#wxEVT_SCI_CHECKBRACE">wxEVT_SCI_CHECKBRACE</a></code> because a common use is to check whether the caret is next to a brace and set highlights on this brace and its corresponding matching brace. This also replaces <a class="message" href="#wxEVT_SCI_POSCHANGED"><code>wxEVT_SCI_POSCHANGED</code></a>, which is now deprecated.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_MODIFIED">wxEVT_SCI_MODIFIED</a></h4>
<p>
This notification is sent when the text or styling of the document changes or is about to change. You can set a mask for the notifications that are sent to the container with <a class="message" href="#SetModEventMask"><code>SetModEventMask</code></a>. The notification structure contains information about what changed, how the change occurred and whether this changed the number of lines in the document. No modifications may be performed while in a <code>wxEVT_SCI_MODIFIED</code> event. The <code>SCNotification</code> fields used are:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Modify notification types"><tbody>
<tr>
  <th align="left">Field</th>
  <th align="left">Usage</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>modificationType</code></td>
  <td align="left">A set of flags that identify the change(s) made. See the next table.</td>
</tr><tr>
  <td align="left"><code>position</code></td>
  <td align="left">Start position of a text or styling change. Set to 0 if not used.</td>
</tr><tr>
  <td align="left"><code>length</code></td>
  <td align="left">Length of the change in cells or characters when the text or styling   changes. Set to 0 if not used.</td>
</tr><tr>
  <td align="left"><code>linesAdded</code></td>
  <td align="left">Number of added lines. If negative, the number of deleted lines. Set to   0 if not used or no lines added or deleted.</td>
</tr><tr>
  <td align="left"><code>text</code></td>
  <td align="left">Valid for text changes, not for style changes. If we are collecting undo   information this holds a pointer to the text that is handed to the Undo system, otherwise   it is zero.</td>
</tr><tr>
  <td align="left"><code>line</code></td>
  <td align="left">The line number at which a fold level or marker change occurred. This is   0 if unused and may be -1 if more than one line changed.</td>
</tr><tr>
  <td align="left"><code>foldLevelNow</code></td>
  <td align="left">The new fold level applied to the line or 0 if this field is unused.</td>
</tr><tr>
  <td align="left"><code>foldLevelPrev</code></td>
  <td align="left">The previous folding level of the line or 0 if this field is unused.</td>
</tr>
</tbody></table>

<p>
The <code>SCNotification.modificationType</code> field has bits set to tell you what has been done. The <code>wxSCI_MOD_*</code> bits correspond to actions. The <code>wxSCI_PERFORMED_...</code> bits tell you if the action was done by the user, or the result of Undo or Redo of a previous action.
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Modify notification type flags"> <tbody>
<tr>
  <th align="left">Symbol</th>
  <th>Value</th>
  <th align="left">Meaning</th>
  <th align="left">SCNotification fields</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>wxSCI_MOD_INSERTTEXT</code></td>
  <td align="center">0x01</td>
  <td>Text has been inserted into the document.</td>
  <td><code>position, length, linesAdded</code></td>
</tr><tr>
  <td align="left"><code>wxSCI_MOD_DELETETEXT</code></td>
  <td align="center">0x02</td>
  <td>Text has been removed from the document.</td>
  <td><code>position, length, linesAdded</code></td>
</tr><tr>
  <td align="left"><code>wxSCI_MOD_CHANGESTYLE</code></td>
  <td align="center">0x04</td>
  <td>A style change has occurred.</td>
  <td><code>position, length</code></td>
</tr><tr>
  <td align="left"><code>wxSCI_MOD_CHANGEFOLD</code></td>
  <td align="center">0x08</td>
  <td>A folding change has occurred.</td>
  <td><code>line, foldLevelNow, foldLevelPrev</code></td>
</tr><tr>
  <td align="left"><code>wxSCI_PERFORMED_USER</code></td>
  <td align="center">0x10</td>
  <td>Information: the operation was done by the user.</td>
  <td>None</td>
</tr><tr>
  <td align="left"><code>wxSCI_PERFORMED_UNDO</code></td>
  <td align="center">0x20</td>
  <td>Information: this was the result of an Undo.</td>
  <td>None</td>
</tr><tr>
  <td align="left"><code>wxSCI_PERFORMED_REDO</code></td>
  <td align="center">0x40</td>
  <td>Information: this was the result of a Redo.</td>
  <td>None</td>
</tr><tr>
  <td align="left"><code>wxSCI_MULTISTEPUNDOREDO</code></td>
  <td align="center">0x80</td>
  <td>This is part of a multi-step Undo or Redo.</td>
  <td>None</td>
</tr><tr>
  <td align="left"><code>wxSCI_LASTSTEPINUNDOREDO</code></td>
  <td align="center">0x100</td>
  <td>This is the final step in an Undo or Redo.</td>
  <td>None</td>
</tr><tr>
  <td align="left"><code>wxSCI_MOD_CHANGEMARKER</code></td>
  <td align="center">0x200</td>
  <td>One or more markers has changed in a line.</td>
  <td><code>line</code></td>
</tr><tr>
  <td align="left"><code>wxSCI_MOD_BEFOREINSERT</code></td>
  <td align="center">0x400</td>
  <td>Text is about to be inserted into the document.</td>
  <td><code>position, length</code></td>
</tr><tr>
  <td align="left"><code>wxSCI_MOD_BEFOREDELETE</code></td>
  <td align="center">0x800</td>
  <td>Text is about to be deleted from the document.</td>
  <td><code>position, length</code></td>
</tr><tr>
  <td align="left"><code>wxSCI_LASTLINEUNDOREDO</code></td>
  <td align="center">0x1000</td>
  <td>This is part of an Undo or Redo with multi-line changes.</td>
  <td>None</td>
</tr><tr>
  <td align="left"><code>wxSCI_MODEVENTMASKALL</code></td>
  <td align="center">0x1FFF</td>
  <td>This is a mask for all valid flags. This is the default mask state set by <a class="message" href="#SetModEventMask"><code>SetModEventMask</code></a>.</td>
  <td>None</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_CHANGE">wxEVT_SCI_CHANGE</a></h4>
<p>
<code>wxEVT_SCI_CHANGE</code> (768) is fired when the text (not the style) of the document changes. This notification is sent using the <code>WM_COMMAND</code> message on Windows and the "Command" signal on GTK+ as this is the behavior of the standard Edit control (<code>wxEVT_SCI_CHANGE</code> has the same value as the Windows Edit control <code>EN_CHANGE</code>). No other information is sent. If you need more detailed information use <a class="message" href="#wxEVT_SCI_MODIFIED"><code>wxEVT_SCI_MODIFIED</code></a>. You can filter the types of changes you are notified about with <a class="message" href="#SetModEventMask"><code>SetModEventMask</code></a>.
</p>

<div class="divider2"></div>
<h4><a name="SetModEventMask">void SetModEventMask (int mask)</a><br />
    <a name="GetModEventMask">int GetModEventMask()</a></h4>
<p>
Set and get an event mask that determines which document change events are notified to the container with <a class="message" href="#wxEVT_SCI_MODIFIED"><code>wxEVT_SCI_MODIFIED</code></a> and <a class="message" href="#wxEVT_SCI_CHANGE"><code>wxEVT_SCI_CHANGE</code></a>. For example, a container may decide to see only notifications about changes to text and not styling changes by calling <code>SetModEventMask(wxSCI_MOD_INSERTTEXT|wxSCI_MOD_DELETETEXT)</code>.
</p>
<p>
The possible notification types are the same as the <code>modificationType</code> bit flags used by <code>wxEVT_SCI_MODIFIED</code>: <code>wxSCI_MOD_INSERTTEXT</code>, <code>wxSCI_MOD_DELETETEXT</code>, <code>wxSCI_MOD_CHANGESTYLE</code>, <code>wxSCI_MOD_CHANGEFOLD</code>, <code>wxSCI_PERFORMED_USER</code>, <code>wxSCI_PERFORMED_UNDO</code>, <code>wxSCI_PERFORMED_REDO</code>, <code>wxSCI_MULTISTEPUNDOREDO</code>, <code>wxSCI_LASTSTEPINUNDOREDO</code>, <code>wxSCI_MOD_CHANGEMARKER</code>, <code>wxSCI_MOD_BEFOREINSERT</code>, <code>wxSCI_MOD_BEFOREDELETE</code>, <code>wxSCI_MULTILINEUNDOREDO</code> and <code>wxSCI_MODEVENTMASKALL</code>.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_MACRORECORD">wxEVT_SCI_MACRORECORD</a></h4>
<p>
The <code><a class="message" href="#StartRecord">StartRecord</a></code> and <a class="message" href="#StopRecord"><code>StopRecord</code></a> enable and disable macro recording. When enabled, each time a recordable change occurs, the <code>wxEVT_SCI_MACRORECORD</code> notification is sent to the container. It is up to the container to record the action. To see the complete list that are recordable, search the Scintilla source <code>Editor.cxx</code> for <code>Editor::NotifyMacroRecord</code>. The fields of <code>SCNotification</code> set in this notification are:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Macro record notification data">   <tbody>
<tr>
  <th align="left">Field</th>
  <th align="left">Usage</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>message</code></td>
  <td align="left">The command that caused the notification.</td>
</tr><tr>
  <td align="left"><code>wParam</code></td>
  <td align="left">The value of <code>wParam</code> in the .</td>
</tr><tr>
  <td align="left"><code>lParam</code></td>
  <td align="left">The value of <code>lParam</code> in the .</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_MARGINCLICK">wxEVT_SCI_MARGINCLICK</a></h4>
<p>
This notification tells the container that the mouse was clicked inside a <a class="jump" href="#Margins">margin</a> that was marked as sensitive (see <a class="message" href="#SetMarginSensitive"><code>SetMarginSensitive</code></a>). This can be used to perform folding or to place breakpoints. The following <code>SCNotification</code> fields are used:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Margin click notification"> <tbody>
<tr>
  <th align="left">Field</th>
  <th align="left">Usage</th>
</tr>
</tbody>  <tbody valign="top">
<tr>
  <td align="left"><code>modifiers</code></td>
  <td align="left">The appropriate combination of <code>SCI_SHIFT</code>,
  <code>SCI_CTRL</code> and <code>SCI_ALT</code> to indicate the keys that were held down   at the time of the margin click.</td>
</tr><tr>
  <td align="left"><code>position</code></td>
  <td align="left">The position of the start of the line in the document that corresponds   to the margin click.</td>
</tr><tr>
  <td align="left"><code>margin</code></td>
  <td align="left">The margin number that was clicked.</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_NEEDSHOWN">wxEVT_SCI_NEEDSHOWN</a></h4>
<p>
Scintilla has determined that a range of lines that is currently invisible should be made visible. An example of where this may be needed is if the end of line of a contracted fold point is deleted. This message is sent to the container in case it wants to make the line visible in some unusual way such as making the whole document visible. Most containers will just ensure each line in the range is visible by calling <a class="message" href="#EnsureVisible"><code>EnsureVisible</code></a>. The <code>position</code> and <code>length</code> fields of <code>SCNotification</code> indicate the range of the document that should be made visible. The container code will be similar to the following code skeleton:
</p>
<pre>
    firstLine = LineFromPosition (scn.position)
    lastLine = LineFromPosition (scn.position+scn.length-1)
    for line = lineStart to lineEnd do EnsureVisible (line) next
</pre>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_PAINTED">wxEVT_SCI_PAINTED</a></h4>
<p>
Painting has just been done. Useful when you want to update some other widgets based on a change in Scintilla, but want to have the paint occur first to appear more responsive. There is no other information in <code>SCNotification</code>.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_USERLISTSELECTION">wxEVT_SCI_USERLISTSELECTION</a></h4>
<p>
The user has selected an item in a <a class="jump" href="#UserLists">user list</a>. The <code>SCNotification</code> fields used are:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="User list notification"><tbody>
<tr>
  <th align="left">Field</th>
  <th align="left">Usage</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>wParam</code></td>
  <td align="left">This is set to the <code>listType</code> parameter from the <a class="message" href="#UserListShow"><code>UserListShow</code></a> that initiated the list.</td>
</tr><tr>
  <td align="left"><code>text</code></td>
  <td align="left">The text of the selection.</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_URIDROPPED">wxEVT_SCI_URIDROPPED</a></h4>
<p>
Only on the GTK+ version. Indicates that the user has dragged a URI such as a file name or Web address onto Scintilla. The container could interpret this as a request to open the file. The <code>text</code> field of <code>SCNotification</code> points at the URI text.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_DWELLSTART">wxEVT_SCI_DWELLSTART</a><br />
    <a name="wxEVT_SCI_DWELLEND">wxEVT_SCI_DWELLEND</a></h4>
<p>
<code>wxEVT_SCI_DWELLSTART</code> is generated when the user keeps the mouse in one position for the dwell period (see <code><a class="message" href="#SetMouseDwellTime">SetMouseDwellTime</a></code>). <code>wxEVT_SCI_DWELLEND</code> is generated after a <code>wxEVT_SCI_DWELLSTART</code> and the mouse is moved or other activity such as key press indicates the dwell is over. Both notifications set the same fields in <code>SCNotification</code>:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Mouse dwell notification"><tbody>
<tr>
  <th align="left">Field</th>
  <th align="left">Usage</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>position</code></td>
  <td align="left">This is the nearest position in the document to the position where the   mouse pointer was lingering.</td>
</tr><tr>
  <td align="left"><code>x, y</code></td>
  <td align="left">Where the pointer lingered. The <code>position</code> field is set to   <code><a class="message" href="#PositionFromPointClose">PositionFromPointClose</a>(x, y)</code>.</td>
</tr>
</tbody></table>

<div class="divider2"></div>
<h4><a name="SetMouseDwellTime">void SetMouseDwellTime (int periodMilliseconds)</a><br />
    <a name="GetMouseDwellTime">int GetMouseDwellTime()</a></h4>
<p>
Set and get the time the mouse must sit still, in milliseconds, to generate a <code><a class="message" href="#wxEVT_SCI_DWELLSTART">wxEVT_SCI_DWELLSTART</a></code> notification. If set to <code>wxSCI_TIME_FOREVER</code>, the default, no dwell events are generated.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_ZOOM">wxEVT_SCI_ZOOM</a></h4>
<p>
This notification is generated when the user zooms the display using the keyboard or the <code><a class="message" href="#SetZoom">SetZoom</a></code> method is called. This notification can be used to recalculate positions, such as the width of the line number margin to maintain sizes in terms of characters rather than pixels. <code>SCNotification</code> has no additional information.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_HOTSPOT_CLICK">wxEVT_SCI_HOTSPOT_CLICK</a><br />
    <a name="wxEVT_SCI_HOTSPOT_DCLICK">wxEVT_SCI_HOTSPOT_DCLICK</a></h4>
<p>
These notifications are generated when the user clicks or double clicks on  text that is in a style with the hotspot attribute set. This notification can be used to link to variable definitions or web pages. The <code>position</code> field is set the text position of the click or double click and the <code>modifiers</code> field set to the key modifiers held down in a similar manner to <a class="message" href="#wxEVT_SCI_KEY">wxEVT_SCI_KEY</a>.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_CALLTIP_CLICK">wxEVT_SCI_CALLTIP_CLICK</a></h4>
<p>
This notification is generated when the user clicks on a calltip. This notification can be used to display the next function prototype when a function name is overloaded with different arguments. The <code>position</code> field is set to 1 if the click is in an up arrow, 2 if in a down arrow, and 0 if elsewhere.
</p>

<div class="divider2"></div>
<h4><a name="wxEVT_SCI_AUTOCOMP_SELECTION">wxEVT_SCI_AUTOCOMP_SELECTION</a></h4>
<p>
The user has selected an item in an <a class="jump" href="#Autocompletion">autocompletion list</a>. The notification is sent before the selection is inserted. Automatic insertion can be cancelled by sending a <code><a class="message" href="#AutoCompCancel">AutoCompCancel</a></code> message before returning from the notification. The <code>SCNotification</code> fields used are:
</p>
<table cellpadding="1" cellspacing="2" border="0" summary="Autocompletion list notification"><tbody>
<tr>
  <th align="left">Field</th>
  <th align="left">Usage</th>
</tr>
</tbody><tbody valign="top">
<tr>
  <td align="left"><code>lParam</code></td>
  <td align="left">The start position of the word being completed.</td>
</tr><tr>
  <td align="left"><code>text</code></td>
  <td align="left">The text of the selection.</td>
</tr>
</tbody></table>

[<a href="index.php" target=_top accesskey="H">Home</a>]
</body>
</html>

